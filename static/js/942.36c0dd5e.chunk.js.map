{"version":3,"file":"static/js/942.36c0dd5e.chunk.js","mappings":"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","sources":["../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","../node_modules/react-chartjs-2/src/utils.ts","../node_modules/react-chartjs-2/src/chart.tsx","../node_modules/react-chartjs-2/src/typedCharts.tsx","../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","../node_modules/@kurkle/color/dist/color.esm.js","../node_modules/chart.js/src/helpers/helpers.core.ts","../node_modules/chart.js/src/helpers/helpers.math.ts","../node_modules/chart.js/src/helpers/helpers.collection.ts","../node_modules/chart.js/src/helpers/helpers.extras.ts","../node_modules/chart.js/src/helpers/helpers.easing.ts","../node_modules/chart.js/src/helpers/helpers.color.ts","../node_modules/chart.js/src/core/core.animations.defaults.js","../node_modules/chart.js/src/helpers/helpers.intl.ts","../node_modules/chart.js/src/core/core.ticks.js","../node_modules/chart.js/src/core/core.defaults.js","../node_modules/chart.js/src/core/core.layouts.defaults.js","../node_modules/chart.js/src/core/core.scale.defaults.js","../node_modules/chart.js/src/helpers/helpers.canvas.ts","../node_modules/chart.js/src/helpers/helpers.options.ts","../node_modules/chart.js/src/helpers/helpers.config.ts","../node_modules/chart.js/src/helpers/helpers.curve.ts","../node_modules/chart.js/src/helpers/helpers.dom.ts","../node_modules/chart.js/src/helpers/helpers.interpolation.ts","../node_modules/chart.js/src/helpers/helpers.rtl.ts","../node_modules/chart.js/src/helpers/helpers.segment.js","../node_modules/chart.js/src/helpers/helpers.dataset.ts","../node_modules/chart.js/src/core/core.animator.js","../node_modules/chart.js/src/core/core.animation.js","../node_modules/chart.js/src/core/core.animations.js","../node_modules/chart.js/src/core/core.datasetController.js","../node_modules/chart.js/src/controllers/controller.bar.js","../node_modules/chart.js/src/controllers/controller.bubble.js","../node_modules/chart.js/src/controllers/controller.doughnut.js","../node_modules/chart.js/src/controllers/controller.line.js","../node_modules/chart.js/src/controllers/controller.polarArea.js","../node_modules/chart.js/src/controllers/controller.pie.js","../node_modules/chart.js/src/controllers/controller.radar.js","../node_modules/chart.js/src/controllers/controller.scatter.js","../node_modules/chart.js/src/core/core.adapters.ts","../node_modules/chart.js/src/core/core.interaction.js","../node_modules/chart.js/src/core/core.layouts.js","../node_modules/chart.js/src/platform/platform.base.js","../node_modules/chart.js/src/platform/platform.basic.js","../node_modules/chart.js/src/platform/platform.dom.js","../node_modules/chart.js/src/core/core.element.ts","../node_modules/chart.js/src/core/core.scale.autoskip.js","../node_modules/chart.js/src/core/core.scale.js","../node_modules/chart.js/src/core/core.typedRegistry.js","../node_modules/chart.js/src/core/core.registry.js","../node_modules/chart.js/src/core/core.plugins.js","../node_modules/chart.js/src/core/core.config.js","../node_modules/chart.js/src/core/core.controller.js","../node_modules/chart.js/src/platform/index.js","../node_modules/chart.js/src/elements/element.arc.ts","../node_modules/chart.js/src/elements/element.line.js","../node_modules/chart.js/src/elements/element.point.ts","../node_modules/chart.js/src/elements/element.bar.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","../node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","../node_modules/chart.js/src/plugins/plugin.filler/index.js","../node_modules/chart.js/src/plugins/plugin.legend.js","../node_modules/chart.js/src/plugins/plugin.title.js","../node_modules/chart.js/src/plugins/plugin.subtitle.js","../node_modules/chart.js/src/plugins/plugin.tooltip.js","../node_modules/chart.js/src/scales/scale.category.js","../node_modules/chart.js/src/scales/scale.linearbase.js","../node_modules/chart.js/src/scales/scale.linear.js","../node_modules/chart.js/src/scales/scale.logarithmic.js","../node_modules/chart.js/src/scales/scale.radialLinear.js","../node_modules/chart.js/src/scales/scale.time.js","../node_modules/motion-utils/dist/es/is-object.mjs","../node_modules/motion-dom/dist/es/render/utils/keys-transform.mjs","../node_modules/motion-dom/dist/es/render/dom/parse-transform.mjs","../node_modules/motion-dom/dist/es/animation/utils/is-css-variable.mjs","../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs","../node_modules/motion-dom/dist/es/utils/mix/number.mjs","../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs","../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","../node_modules/framer-motion/dist/es/projection/utils/measure.mjs","../node_modules/motion-dom/dist/es/render/utils/keys-position.mjs","../node_modules/motion-utils/dist/es/clamp.mjs","../node_modules/motion-dom/dist/es/value/types/numbers/index.mjs","../node_modules/motion-dom/dist/es/value/types/numbers/units.mjs","../node_modules/motion-dom/dist/es/value/types/test.mjs","../node_modules/motion-dom/dist/es/value/types/dimensions.mjs","../node_modules/motion-dom/dist/es/value/types/auto.mjs","../node_modules/motion-utils/dist/es/is-numerical-string.mjs","../node_modules/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs","../node_modules/motion-utils/dist/es/noop.mjs","../node_modules/motion-utils/dist/es/global-config.mjs","../node_modules/motion-dom/dist/es/frameloop/order.mjs","../node_modules/motion-dom/dist/es/stats/buffer.mjs","../node_modules/motion-dom/dist/es/frameloop/batcher.mjs","../node_modules/motion-dom/dist/es/frameloop/render-step.mjs","../node_modules/motion-dom/dist/es/frameloop/frame.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs","../node_modules/motion-utils/dist/es/is-zero-value-string.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs","../node_modules/motion-dom/dist/es/value/types/utils/sanitize.mjs","../node_modules/motion-dom/dist/es/value/types/utils/float-regex.mjs","../node_modules/motion-dom/dist/es/value/types/utils/single-color-regex.mjs","../node_modules/motion-dom/dist/es/value/types/color/utils.mjs","../node_modules/motion-dom/dist/es/value/types/utils/is-nullish.mjs","../node_modules/motion-dom/dist/es/value/types/color/rgba.mjs","../node_modules/motion-dom/dist/es/value/types/color/hex.mjs","../node_modules/motion-dom/dist/es/value/types/color/hsla.mjs","../node_modules/motion-dom/dist/es/value/types/color/index.mjs","../node_modules/motion-dom/dist/es/value/types/utils/color-regex.mjs","../node_modules/motion-dom/dist/es/value/types/complex/index.mjs","../node_modules/motion-dom/dist/es/value/types/complex/filter.mjs","../node_modules/motion-dom/dist/es/value/types/int.mjs","../node_modules/motion-dom/dist/es/value/types/maps/number.mjs","../node_modules/motion-dom/dist/es/value/types/maps/transform.mjs","../node_modules/motion-dom/dist/es/value/types/maps/defaults.mjs","../node_modules/motion-dom/dist/es/value/types/utils/animatable-none.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs","../node_modules/motion-dom/dist/es/value/utils/is-motion-value.mjs","../node_modules/motion-dom/dist/es/frameloop/sync-time.mjs","../node_modules/motion-utils/dist/es/array.mjs","../node_modules/motion-utils/dist/es/subscription-manager.mjs","../node_modules/motion-utils/dist/es/velocity-per-second.mjs","../node_modules/motion-dom/dist/es/value/index.mjs","../node_modules/motion-dom/dist/es/value/types/utils/find.mjs","../node_modules/motion-dom/dist/es/frameloop/microtask.mjs","../node_modules/framer-motion/dist/es/motion/features/definitions.mjs","../node_modules/framer-motion/dist/es/projection/geometry/models.mjs","../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs","../node_modules/framer-motion/dist/es/render/store.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs","../node_modules/framer-motion/dist/es/render/utils/variant-props.mjs","../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs","../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs","../node_modules/framer-motion/dist/es/render/VisualElement.mjs","../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs","../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs","../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs","../node_modules/motion-dom/dist/es/value/types/utils/get-as-type.mjs","../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs","../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs","../node_modules/framer-motion/dist/es/render/html/utils/render.mjs","../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs","../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs","../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs","../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs","../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs","../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs","../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs","../node_modules/framer-motion/dist/es/context/LazyContext.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs","../node_modules/framer-motion/dist/es/render/html/use-props.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs","../node_modules/framer-motion/dist/es/render/svg/use-props.mjs","../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs","../node_modules/framer-motion/dist/es/render/dom/use-render.mjs","../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs","../node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs","../node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs","../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs","../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs","../node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","../node_modules/framer-motion/dist/es/motion/index.mjs","../node_modules/framer-motion/dist/es/motion/features/load-features.mjs","../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs","../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs","../node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","../node_modules/framer-motion/dist/es/render/utils/setters.mjs","../node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs","../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs","../node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","../node_modules/motion-dom/dist/es/animation/utils/make-animation-instant.mjs","../node_modules/motion-utils/dist/es/pipe.mjs","../node_modules/motion-utils/dist/es/time-conversion.mjs","../node_modules/motion-dom/dist/es/stats/animation-count.mjs","../node_modules/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs","../node_modules/motion-dom/dist/es/utils/mix/immediate.mjs","../node_modules/motion-dom/dist/es/utils/mix/color.mjs","../node_modules/motion-dom/dist/es/utils/mix/visibility.mjs","../node_modules/motion-dom/dist/es/utils/mix/complex.mjs","../node_modules/motion-dom/dist/es/utils/mix/index.mjs","../node_modules/motion-dom/dist/es/animation/drivers/frame.mjs","../node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/velocity.mjs","../node_modules/motion-dom/dist/es/animation/generators/spring/defaults.mjs","../node_modules/motion-dom/dist/es/animation/generators/spring/find.mjs","../node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs","../node_modules/motion-dom/dist/es/animation/generators/inertia.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs","../node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs","../node_modules/motion-utils/dist/es/easing/ease.mjs","../node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs","../node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs","../node_modules/motion-utils/dist/es/easing/back.mjs","../node_modules/motion-utils/dist/es/easing/anticipate.mjs","../node_modules/motion-utils/dist/es/easing/circ.mjs","../node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs","../node_modules/motion-utils/dist/es/easing/utils/map.mjs","../node_modules/motion-utils/dist/es/progress.mjs","../node_modules/motion-dom/dist/es/utils/interpolate.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/offsets/default.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs","../node_modules/motion-dom/dist/es/animation/generators/keyframes.mjs","../node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/offsets/time.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/get-final.mjs","../node_modules/motion-dom/dist/es/animation/utils/replace-transition-type.mjs","../node_modules/motion-dom/dist/es/animation/utils/WithPromise.mjs","../node_modules/motion-dom/dist/es/animation/JSAnimation.mjs","../node_modules/motion-utils/dist/es/memo.mjs","../node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../node_modules/motion-dom/dist/es/utils/supports/flags.mjs","../node_modules/motion-dom/dist/es/utils/supports/memo.mjs","../node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs","../node_modules/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs","../node_modules/motion-dom/dist/es/animation/waapi/easing/supported.mjs","../node_modules/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs","../node_modules/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs","../node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs","../node_modules/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs","../node_modules/motion-dom/dist/es/render/dom/style-set.mjs","../node_modules/motion-dom/dist/es/render/dom/is-css-var.mjs","../node_modules/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs","../node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs","../node_modules/motion-dom/dist/es/animation/utils/is-animatable.mjs","../node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs","../node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs","../node_modules/motion-dom/dist/es/animation/utils/can-animate.mjs","../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","../node_modules/framer-motion/dist/es/animation/utils/calc-child-stagger.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs","../node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs","../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","../node_modules/framer-motion/dist/es/motion/features/Feature.mjs","../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs","../node_modules/framer-motion/dist/es/motion/features/animations.mjs","../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs","../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs","../node_modules/framer-motion/dist/es/events/add-dom-event.mjs","../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs","../node_modules/framer-motion/dist/es/events/event-info.mjs","../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs","../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs","../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs","../node_modules/framer-motion/dist/es/utils/get-context-window.mjs","../node_modules/framer-motion/dist/es/utils/distance.mjs","../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs","../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs","../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs","../node_modules/framer-motion/dist/es/gestures/pan/index.mjs","../node_modules/framer-motion/dist/es/projection/node/state.mjs","../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs","../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs","../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs","../node_modules/motion-dom/dist/es/utils/is-svg-element.mjs","../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs","../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs","../node_modules/framer-motion/dist/es/utils/delay.mjs","../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs","../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs","../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs","../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs","../node_modules/framer-motion/dist/es/projection/shared/stack.mjs","../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs","../node_modules/motion-dom/dist/es/utils/is-svg-svg-element.mjs","../node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","../node_modules/framer-motion/dist/es/projection/styles/transform.mjs","../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs","../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs","../node_modules/framer-motion/dist/es/motion/features/drag.mjs","../node_modules/framer-motion/dist/es/gestures/drag/index.mjs","../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs","../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs","../node_modules/motion-dom/dist/es/gestures/hover.mjs","../node_modules/framer-motion/dist/es/gestures/hover.mjs","../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs","../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs","../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs","../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs","../node_modules/motion-dom/dist/es/gestures/press/index.mjs","../node_modules/framer-motion/dist/es/gestures/press.mjs","../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs","../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","../node_modules/framer-motion/dist/es/motion/features/gestures.mjs","../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs","../node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs","../node_modules/framer-motion/dist/es/gestures/focus.mjs","../node_modules/framer-motion/dist/es/motion/features/layout.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../node_modules/framer-motion/dist/es/context/PresenceContext.mjs","../node_modules/motion-dom/dist/es/utils/is-html-element.mjs","../node_modules/framer-motion/dist/es/utils/is-browser.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","../node_modules/framer-motion/dist/es/utils/use-constant.mjs"],"sourcesContent":["\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst MotionConfigContext = createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\nexport { MotionConfigContext };\n","import type { MouseEvent } from 'react';\nimport type {\n  ChartType,\n  ChartData,\n  DefaultDataPoint,\n  ChartDataset,\n  ChartOptions,\n  Chart,\n} from 'chart.js';\n\nimport type { ForwardedRef } from './types.js';\n\nconst defaultDatasetIdKey = 'label';\n\nexport function reforwardRef<T>(ref: ForwardedRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nexport function setOptions<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(chart: Chart<TType, TData, TLabel>, nextOptions: ChartOptions<TType>) {\n  const options = chart.options;\n\n  if (options && nextOptions) {\n    Object.assign(options, nextOptions);\n  }\n}\n\nexport function setLabels<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(\n  currentData: ChartData<TType, TData, TLabel>,\n  nextLabels: TLabel[] | undefined\n) {\n  currentData.labels = nextLabels;\n}\n\nexport function setDatasets<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(\n  currentData: ChartData<TType, TData, TLabel>,\n  nextDatasets: ChartDataset<TType, TData>[],\n  datasetIdKey = defaultDatasetIdKey\n) {\n  const addedDatasets: ChartDataset<TType, TData>[] = [];\n\n  currentData.datasets = nextDatasets.map(\n    (nextDataset: Record<string, unknown>) => {\n      // given the new set, find it's current match\n      const currentDataset = currentData.datasets.find(\n        (dataset: Record<string, unknown>) =>\n          dataset[datasetIdKey] === nextDataset[datasetIdKey]\n      );\n\n      // There is no original to update, so simply add new one\n      if (\n        !currentDataset ||\n        !nextDataset.data ||\n        addedDatasets.includes(currentDataset)\n      ) {\n        return { ...nextDataset } as ChartDataset<TType, TData>;\n      }\n\n      addedDatasets.push(currentDataset);\n\n      Object.assign(currentDataset, nextDataset);\n\n      return currentDataset;\n    }\n  );\n}\n\nexport function cloneData<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(data: ChartData<TType, TData, TLabel>, datasetIdKey = defaultDatasetIdKey) {\n  const nextData: ChartData<TType, TData, TLabel> = {\n    labels: [],\n    datasets: [],\n  };\n\n  setLabels(nextData, data.labels);\n  setDatasets(nextData, data.datasets, datasetIdKey);\n\n  return nextData;\n}\n\n/**\n * Get dataset from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getDatasetAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'dataset',\n    { intersect: true },\n    false\n  );\n}\n\n/**\n * Get single dataset element from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getElementAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'nearest',\n    { intersect: true },\n    false\n  );\n}\n\n/**\n * Get all dataset elements from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getElementsAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'index',\n    { intersect: true },\n    false\n  );\n}\n","import React, { useEffect, useRef, forwardRef } from 'react';\nimport { Chart as ChartJS } from 'chart.js';\nimport type { ChartType, DefaultDataPoint } from 'chart.js';\n\nimport type { ForwardedRef, ChartProps, BaseChartComponent } from './types.js';\nimport {\n  reforwardRef,\n  cloneData,\n  setOptions,\n  setLabels,\n  setDatasets,\n} from './utils.js';\n\nfunction ChartComponent<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(\n  props: ChartProps<TType, TData, TLabel>,\n  ref: ForwardedRef<ChartJS<TType, TData, TLabel>>\n) {\n  const {\n    height = 150,\n    width = 300,\n    redraw = false,\n    datasetIdKey,\n    type,\n    data,\n    options,\n    plugins = [],\n    fallbackContent,\n    updateMode,\n    ...canvasProps\n  } = props;\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const chartRef = useRef<ChartJS<TType, TData, TLabel> | null>(null);\n\n  const renderChart = () => {\n    if (!canvasRef.current) return;\n\n    chartRef.current = new ChartJS(canvasRef.current, {\n      type,\n      data: cloneData(data, datasetIdKey),\n      options: options && { ...options },\n      plugins,\n    });\n\n    reforwardRef(ref, chartRef.current);\n  };\n\n  const destroyChart = () => {\n    reforwardRef(ref, null);\n\n    if (chartRef.current) {\n      chartRef.current.destroy();\n      chartRef.current = null;\n    }\n  };\n\n  useEffect(() => {\n    if (!redraw && chartRef.current && options) {\n      setOptions(chartRef.current, options);\n    }\n  }, [redraw, options]);\n\n  useEffect(() => {\n    if (!redraw && chartRef.current) {\n      setLabels(chartRef.current.config.data, data.labels);\n    }\n  }, [redraw, data.labels]);\n\n  useEffect(() => {\n    if (!redraw && chartRef.current && data.datasets) {\n      setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);\n    }\n  }, [redraw, data.datasets]);\n\n  useEffect(() => {\n    if (!chartRef.current) return;\n\n    if (redraw) {\n      destroyChart();\n      setTimeout(renderChart);\n    } else {\n      chartRef.current.update(updateMode);\n    }\n  }, [redraw, options, data.labels, data.datasets, updateMode]);\n\n  useEffect(() => {\n    if (!chartRef.current) return;\n\n    destroyChart();\n    setTimeout(renderChart);\n  }, [type]);\n\n  useEffect(() => {\n    renderChart();\n\n    return () => destroyChart();\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      role='img'\n      height={height}\n      width={width}\n      {...canvasProps}\n    >\n      {fallbackContent}\n    </canvas>\n  );\n}\n\nexport const Chart = forwardRef(ChartComponent) as BaseChartComponent;\n","import React, { forwardRef } from 'react';\nimport {\n  Chart as ChartJS,\n  LineController,\n  BarController,\n  RadarController,\n  DoughnutController,\n  PolarAreaController,\n  BubbleController,\n  PieController,\n  ScatterController,\n} from 'chart.js';\nimport type { ChartType, ChartComponentLike } from 'chart.js';\n\nimport type {\n  ChartProps,\n  ChartJSOrUndefined,\n  TypedChartComponent,\n} from './types.js';\nimport { Chart } from './chart.js';\n\nfunction createTypedChart<T extends ChartType>(\n  type: T,\n  registerables: ChartComponentLike\n) {\n  ChartJS.register(registerables);\n\n  return forwardRef<ChartJSOrUndefined<T>, Omit<ChartProps<T>, 'type'>>(\n    (props, ref) => <Chart {...props} ref={ref} type={type} />\n  ) as TypedChartComponent<T>;\n}\n\nexport const Line = /* #__PURE__ */ createTypedChart('line', LineController);\n\nexport const Bar = /* #__PURE__ */ createTypedChart('bar', BarController);\n\nexport const Radar = /* #__PURE__ */ createTypedChart('radar', RadarController);\n\nexport const Doughnut = /* #__PURE__ */ createTypedChart(\n  'doughnut',\n  DoughnutController\n);\n\nexport const PolarArea = /* #__PURE__ */ createTypedChart(\n  'polarArea',\n  PolarAreaController\n);\n\nexport const Bubble = /* #__PURE__ */ createTypedChart(\n  'bubble',\n  BubbleController\n);\n\nexport const Pie = /* #__PURE__ */ createTypedChart('pie', PieController);\n\nexport const Scatter = /* #__PURE__ */ createTypedChart(\n  'scatter',\n  ScatterController\n);\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LayoutGroupContext = createContext({});\n\nexport { LayoutGroupContext };\n","import { useLayoutEffect, useEffect } from 'react';\nimport { isBrowser } from './is-browser.mjs';\n\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\n\nexport { useIsomorphicLayoutEffect };\n","/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */\nfunction isNonPrimitive(n: unknown) {\n  return typeof n === 'symbol' || (typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n));\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNonPrimitive(n) && !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\nimport {isNullOrUndef} from './helpers.core.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, vScale, _parsed} = meta;\n    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n      if (spanGaps) {\n        const distanceToDefinedLo = (_parsed\n          .slice(0, start + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        start -= Math.max(0, distanceToDefinedLo);\n      }\n      start = _limitValue(start, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      let end = Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n      if (spanGaps) {\n        const distanceToDefinedHi = (_parsed\n          .slice(end - 1)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        end += Math.max(0, distanceToDefinedHi);\n      }\n      count = _limitValue(end, start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  if (!ctx && !canvas) {\n    return;\n  }\n\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type PrivateChart from '../core/core.controller.js';\nimport type {Chart, ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart | PrivateChart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart | PrivateChart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  (chart as PrivateChart).height = Math.floor(chart.height);\n  (chart as PrivateChart).width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    (chart as PrivateChart).currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import type {Chart, ChartArea, ChartMeta, Scale, TRBL} from '../types/index.js';\n\nfunction getSizeForArea(scale: Scale, chartArea: ChartArea, field: keyof ChartArea) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta: ChartMeta, chartArea: ChartArea): TRBL {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nexport function getDatasetClipArea(chart: Chart, meta: ChartMeta): TRBL | false {\n  const clip = meta._clip;\n  if (clip.disabled) {\n    return false;\n  }\n  const area = getDatasetArea(meta, chart.chartArea);\n\n  return {\n    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n  };\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n\n  if (!found && !options.all) {\n    return 0;\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data, meta) {\n  const {iScale, vScale} = meta;\n  const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n  const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find(item => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  _getAxisCount() {\n    return this._getAxis().length;\n  }\n\n  getFirstScaleIdForIndexAxis() {\n    const scales = this.chart.scales;\n    const indexScaleId = this.chart.options.indexAxis;\n    return Object.keys(scales).filter(key => scales[key].axis === indexScaleId).shift();\n  }\n\n  _getAxis() {\n    const axis = {};\n    const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n    for (const dataset of this.chart.data.datasets) {\n      axis[valueOrDefault(\n        this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId\n      )] = true;\n    }\n    return Object.keys(axis);\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    const axisCount = this._getAxisCount();\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n      const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n      const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<TimeUnit | 'datetime', string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: string): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: string): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number | boolean): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options?: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<TimeUnit | 'datetime', string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase as {\n    new (options?: AnyObject): DateAdapter;\n    override<T extends AnyObject = AnyObject>(\n      members: Partial<Omit<DateAdapter<T>, 'options'>>\n    ): void;\n  }\n};\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea, isNullOrUndef} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      const result = lookupMethod(data, axis, value);\n      if (spanGaps) {\n        const {vScale} = controller._cachedMeta;\n        const {_parsed} = metaset;\n\n        const distanceToDefinedLo = (_parsed\n          .slice(0, result.lo + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.lo -= Math.max(0, distanceToDefinedLo);\n\n        const distanceToDefinedHi = (_parsed\n          .slice(result.hi)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.hi += Math.max(0, distanceToDefinedHi);\n      }\n      return result;\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea, _isDomSupported, retinaScale, getDatasetClipArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      // Unset pending resize request now to avoid possible recursion within _resize\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    // @ts-expect-error\n    const clip = getDatasetClipArea(this, meta);\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (clip) {\n      clipArea(ctx, clip);\n    }\n\n    meta.controller.draw();\n\n    if (clip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the event inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _angleDiff, _normalizeAngle, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\nfunction clipSelf(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, x, y, outerRadius, innerRadius, options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n\n  if (innerRadius > 0) {\n    const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));\n    ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n  } else {\n    const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));\n\n    if (borderJoinStyle === 'round') {\n      ctx.arc(x, y, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);\n    } else if (borderJoinStyle === 'bevel') {\n      const r = 2 * clipWidth * clipWidth;\n      const endX = -r * Math.cos(endAngle + PI / 2) + x;\n      const endY = -r * Math.sin(endAngle + PI / 2) + y;\n      const startX = r * Math.cos(startAngle + PI / 2) + x;\n      const startY = r * Math.sin(startAngle + PI / 2) + y;\n      ctx.lineTo(endX, endY);\n      ctx.lineTo(startX, startY);\n    }\n  }\n  ctx.closePath();\n\n  ctx.moveTo(0, 0);\n  ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  ctx.clip('evenodd');\n}\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, 𝜃) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== 'miter') {\n    clipSelf(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n    selfJoin: false,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of a segment -> need to add another point before this,\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of a segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea, getDatasetClipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {chart, index, line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  const meta = chart.getDatasetMeta(index);\n  const clip = getDatasetClipArea(chart, meta);\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis, clip});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale, clip} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  let fillColor = below;\n  if (below !== above) {\n    if (property === 'x') {\n      clipVertical(ctx, target, area.top);\n      fill(ctx, {line, target, color: above, scale, property, clip});\n      ctx.restore();\n      ctx.save();\n      clipVertical(ctx, target, area.bottom);\n    } else if (property === 'y') {\n      clipHorizontal(ctx, target, area.left);\n      fill(ctx, {line, target, color: below, scale, property, clip});\n      ctx.restore();\n      ctx.save();\n      clipHorizontal(ctx, target, area.right);\n      fillColor = above;\n    }\n  }\n  fill(ctx, {line, target, color: fillColor, scale, property, clip});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction clipHorizontal(ctx, target, clipX) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(clipX, firstPoint.y);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(clipX, lastPoint.y);\n    }\n  }\n\n  ctx.lineTo(clipX, target.first().y);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale, clip} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, clip, bounds) {\n  const chartArea = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n\n  if (property === 'x' || property === 'y') {\n    let left, top, right, bottom;\n\n    if (property === 'x') {\n      left = start;\n      top = chartArea.top;\n      right = end;\n      bottom = chartArea.bottom;\n    } else {\n      left = chartArea.left;\n      top = start;\n      right = chartArea.right;\n      bottom = end;\n    }\n\n    ctx.beginPath();\n\n    if (clip) {\n      left = Math.max(left, clip.left);\n      right = Math.min(right, clip.right);\n      top = Math.max(top, clip.top);\n      bottom = Math.min(bottom, clip.bottom);\n    }\n\n    ctx.rect(left, top, right - left, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let xSet = new Set();\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    // No visible items where found, return false so we don't have to divide by 0 which reduces in NaN\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0 || (index === 0 && this.min < 0)) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if ((index === 0 && this.min >= 0) && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","function isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\nexport { isObject };\n","/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = /*@__PURE__*/ (() => new Set(transformPropOrder))();\n\nexport { transformPropOrder, transformProps };\n","const radToDeg = (rad) => (rad * 180) / Math.PI;\nconst rotate = (v) => {\n    const angle = radToDeg(Math.atan2(v[1], v[0]));\n    return rebaseAngle(angle);\n};\nconst matrix2dParsers = {\n    x: 4,\n    y: 5,\n    translateX: 4,\n    translateY: 5,\n    scaleX: 0,\n    scaleY: 3,\n    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,\n    rotate,\n    rotateZ: rotate,\n    skewX: (v) => radToDeg(Math.atan(v[1])),\n    skewY: (v) => radToDeg(Math.atan(v[2])),\n    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2,\n};\nconst rebaseAngle = (angle) => {\n    angle = angle % 360;\n    if (angle < 0)\n        angle += 360;\n    return angle;\n};\nconst rotateZ = rotate;\nconst scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);\nconst scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);\nconst matrix3dParsers = {\n    x: 12,\n    y: 13,\n    z: 14,\n    translateX: 12,\n    translateY: 13,\n    translateZ: 14,\n    scaleX,\n    scaleY,\n    scale: (v) => (scaleX(v) + scaleY(v)) / 2,\n    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),\n    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),\n    rotateZ,\n    rotate: rotateZ,\n    skewX: (v) => radToDeg(Math.atan(v[4])),\n    skewY: (v) => radToDeg(Math.atan(v[1])),\n    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2,\n};\nfunction defaultTransformValue(name) {\n    return name.includes(\"scale\") ? 1 : 0;\n}\nfunction parseValueFromTransform(transform, name) {\n    if (!transform || transform === \"none\") {\n        return defaultTransformValue(name);\n    }\n    const matrix3dMatch = transform.match(/^matrix3d\\(([-\\d.e\\s,]+)\\)$/u);\n    let parsers;\n    let match;\n    if (matrix3dMatch) {\n        parsers = matrix3dParsers;\n        match = matrix3dMatch;\n    }\n    else {\n        const matrix2dMatch = transform.match(/^matrix\\(([-\\d.e\\s,]+)\\)$/u);\n        parsers = matrix2dParsers;\n        match = matrix2dMatch;\n    }\n    if (!match) {\n        return defaultTransformValue(name);\n    }\n    const valueParser = parsers[name];\n    const values = match[1].split(\",\").map(convertTransformToNumber);\n    return typeof valueParser === \"function\"\n        ? valueParser(values)\n        : values[valueParser];\n}\nconst readTransformValue = (instance, name) => {\n    const { transform = \"none\" } = getComputedStyle(instance);\n    return parseValueFromTransform(transform, name);\n};\nfunction convertTransformToNumber(value) {\n    return parseFloat(value.trim());\n}\n\nexport { defaultTransformValue, parseValueFromTransform, readTransformValue };\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\nexport { isCSSVariableName, isCSSVariableToken };\n","/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nexport { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };\n","/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\nexport { mixNumber };\n","function isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY ||\n        values.skewX ||\n        values.skewY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\nexport { has2DTranslate, hasScale, hasTransform };\n","import { mixNumber } from 'motion-dom';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n","import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';\nimport { translateAxis } from '../geometry/delta-apply.mjs';\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\nexport { measurePageBox, measureViewportBox };\n","import { transformPropOrder } from './keys-transform.mjs';\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    ...transformPropOrder,\n]);\n\nexport { positionalKeys };\n","const clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexport { clamp };\n","import { clamp } from 'motion-utils';\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\nexport { alpha, number, scale };\n","/*#__NO_SIDE_EFFECTS__*/\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = /*@__PURE__*/ (() => ({\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n}))();\n\nexport { degrees, percent, progressPercentage, px, vh, vw };\n","/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\nexport { testValueType };\n","import { auto } from './auto.mjs';\nimport { number } from './numbers/index.mjs';\nimport { px, percent, degrees, vw, vh } from './numbers/units.mjs';\nimport { testValueType } from './test.mjs';\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\nexport { dimensionValueTypes, findDimensionValueType };\n","/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\nexport { auto };\n","/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\nexport { isNumericalString };\n","import { invariant, isNumericalString } from 'motion-utils';\nimport { isCSSVariableToken } from './is-css-variable.mjs';\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = \n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token1, token2, fallback] = match;\n    return [`--${token1 ?? token2}`, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`, \"max-css-var-depth\");\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback)\n        ? getVariableValue(fallback, element, depth + 1)\n        : fallback;\n}\n\nexport { getVariableValue, parseCSSVariable };\n","import { parseValueFromTransform } from '../../../render/dom/parse-transform.mjs';\nimport { transformPropOrder } from '../../../render/utils/keys-transform.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: (_bbox, { transform }) => parseValueFromTransform(transform, \"x\"),\n    y: (_bbox, { transform }) => parseValueFromTransform(transform, \"y\"),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n","const MotionGlobalConfig = {};\n\nexport { MotionGlobalConfig };\n","const stepsOrder = [\n    \"setup\", // Compute\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"preUpdate\", // Compute\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\n\nexport { stepsOrder };\n","const statsBuffer = {\n    value: null,\n    addProjectionMetrics: null,\n};\n\nexport { statsBuffer };\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { stepsOrder } from './order.mjs';\nimport { createRenderStep } from './render-step.mjs';\n\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\n        return acc;\n    }, {});\n    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender, } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        if (!MotionGlobalConfig.useManualTiming) {\n            state.delta = useDefaultElapsed\n                ? 1000 / 60\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        }\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        setup.process(state);\n        read.process(state);\n        resolveKeyframes.process(state);\n        preUpdate.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nexport { createRenderBatcher };\n","import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n","import { noop } from 'motion-utils';\nimport { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\nexport { cancelFrame, frame, frameData, frameSteps };\n","import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete(isForced));\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    isForced = true;\n    readAllKeyframes();\n    measureAllKeyframes();\n    isForced = false;\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        this.state = \"pending\";\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.state = \"scheduled\";\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get();\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue;\n            }\n            else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe);\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead;\n                }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0]);\n            }\n        }\n        fillWildcards(unresolvedKeyframes);\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete(isForcedComplete = false) {\n        this.state = \"complete\";\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (this.state === \"scheduled\") {\n            toResolve.delete(this);\n            this.state = \"pending\";\n        }\n    }\n    resume() {\n        if (this.state === \"pending\")\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n","function fillWildcards(keyframes) {\n    for (let i = 1; i < keyframes.length; i++) {\n        keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);\n    }\n}\n\nexport { fillWildcards };\n","/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\nexport { isZeroValueString };\n","import { isZeroValueString } from 'motion-utils';\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\nexport { isNone };\n","// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\nexport { sanitize };\n","const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\nexport { floatRegex };\n","const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\nexport { singleColorRegex };\n","import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === \"string\" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== \"string\")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nexport { isColorString, splitColor };\n","function isNullish(v) {\n    return v == null;\n}\n\nexport { isNullish };\n","import { clamp } from 'motion-utils';\nimport { number, alpha } from '../numbers/index.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nexport { rgbUnit, rgba };\n","import { rgba } from './rgba.mjs';\nimport { isColorString } from './utils.mjs';\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nexport { hex };\n","import { alpha } from '../numbers/index.mjs';\nimport { percent } from '../numbers/units.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nexport { hsla };\n","import { hex } from './hex.mjs';\nimport { hsla } from './hsla.mjs';\nimport { rgba } from './rgba.mjs';\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === \"string\"\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n    getAnimatableNone: (v) => {\n        const parsed = color.parse(v);\n        parsed.alpha = 0;\n        return color.transform(parsed);\n    },\n};\n\nexport { color };\n","const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\nexport { colorRegex };\n","import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n    return (isNaN(v) &&\n        typeof v === \"string\" &&\n        (v.match(floatRegex)?.length || 0) +\n            (v.match(colorRegex)?.length || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n","import { complex } from './index.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    },\n};\n\nexport { filter };\n","import { number } from './numbers/index.mjs';\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nexport { int };\n","import { int } from '../int.mjs';\nimport { alpha } from '../numbers/index.mjs';\nimport { px } from '../numbers/units.mjs';\nimport { transformValueTypes } from './transform.mjs';\n\nconst numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n    ...transformValueTypes,\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nexport { numberValueTypes };\n","import { scale, alpha } from '../numbers/index.mjs';\nimport { degrees, px, progressPercentage } from '../numbers/units.mjs';\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\nexport { transformValueTypes };\n","import { color } from '../color/index.mjs';\nimport { filter } from '../complex/filter.mjs';\nimport { numberValueTypes } from './number.mjs';\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nexport { defaultValueTypes, getDefaultValueType };\n","import { complex } from '../complex/index.mjs';\nimport { filter } from '../complex/filter.mjs';\nimport { getDefaultValueType } from '../maps/defaults.mjs';\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\nexport { getAnimatableNone };\n","import { analyseComplexValue } from '../../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../../../value/types/utils/animatable-none.mjs';\n\n/**\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\n */\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\" &&\n            !invalidTemplates.has(keyframe) &&\n            analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\n\nexport { makeNoneKeyframesAnimatable };\n","import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else if (positionalValues[name]) {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n","const isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nexport { isMotionValue };\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { frameData } from './frame.mjs';\n\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n    now: () => {\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\n                ? frameData.timestamp\n                : performance.now());\n        }\n        return now;\n    },\n    set: (newTime) => {\n        now = newTime;\n        queueMicrotask(clearTime);\n    },\n};\n\nexport { time };\n","function addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nexport { addUniqueItem, moveItem, removeItem };\n","import { addUniqueItem, removeItem } from './array.mjs';\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\nexport { SubscriptionManager };\n","/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n","import { warnOnce, SubscriptionManager, velocityPerSecond } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     */\n    constructor(init, options = {}) {\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = null;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v) => {\n            const currentTime = time.now();\n            /**\n             * If we're updating the value during another frame or eventloop\n             * than the previous frame, then the we set the previous frame value\n             * to current.\n             */\n            if (this.updatedAt !== currentTime) {\n                this.setPrevFrameValue();\n            }\n            this.prev = this.current;\n            this.setCurrent(v);\n            // Update update subscribers\n            if (this.current !== this.prev) {\n                this.events.change?.notify(this.current);\n                if (this.dependents) {\n                    for (const dependent of this.dependents) {\n                        dependent.dirty();\n                    }\n                }\n            }\n        };\n        this.hasAnimated = false;\n        this.setCurrent(init);\n        this.owner = options.owner;\n    }\n    setCurrent(current) {\n        this.current = current;\n        this.updatedAt = time.now();\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current);\n        }\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n        this.prevFrameValue = prevFrameValue;\n        this.prevUpdatedAt = this.updatedAt;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v) {\n        if (!this.passiveEffect) {\n            this.updateAndNotify(v);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = undefined;\n        this.prevFrameValue = prev;\n        this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v, endAnimation = true) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\n        endAnimation && this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    dirty() {\n        this.events.change?.notify(this.current);\n    }\n    addDependent(dependent) {\n        if (!this.dependents) {\n            this.dependents = new Set();\n        }\n        this.dependents.add(dependent);\n    }\n    removeDependent(dependent) {\n        if (this.dependents) {\n            this.dependents.delete(dependent);\n        }\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now();\n        if (!this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n            return 0;\n        }\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n        // Casts because of parseFloat's poor typing\n        return velocityPerSecond(parseFloat(this.current) -\n            parseFloat(this.prevFrameValue), delta);\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.dependents?.clear();\n        this.events.destroy?.notify();\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\nexport { MotionValue, collectMotionValues, motionValue };\n","import { color } from '../color/index.mjs';\nimport { complex } from '../complex/index.mjs';\nimport { dimensionValueTypes } from '../dimensions.mjs';\nimport { testValueType } from '../test.mjs';\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\nexport { findValueType };\n","import { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: microtask, cancel: cancelMicrotask } = \n/* @__PURE__ */ createRenderBatcher(queueMicrotask, false);\n\nexport { cancelMicrotask, microtask };\n","const featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nexport { featureDefinitions };\n","const createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\nexport { createAxis, createAxisDelta, createBox, createDelta };\n","// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nexport { hasReducedMotionListener, prefersReducedMotion };\n","const visualElementStore = new WeakMap();\n\nexport { visualElementStore };\n","function isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nexport { isAnimationControls };\n","/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nexport { isVariantLabel };\n","const variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nexport { variantPriorityOrder, variantProps };\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nexport { isControllingVariants, isVariantNode };\n","function getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement?.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\nexport { resolveVariantFromProps };\n","import { KeyframeResolver, time, frame, isMotionValue, cancelFrame, transformProps, motionValue, findValueType, complex, getAnimatableNone, microtask } from 'motion-dom';\nimport { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key]);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n        }\n        this.parent?.addChild(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent?.removeChild(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    addChild(child) {\n        this.children.add(child);\n        this.enteringChildren ?? (this.enteringChildren = new Set());\n        this.enteringChildren.add(child);\n    }\n    removeChild(child) {\n        this.children.delete(child);\n        this.enteringChildren && this.enteringChildren.delete(child);\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform();\n        }\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n            this.scheduleRender();\n        });\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : this.getBaseTargetFromProps(this.props, key) ??\n                this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n    scheduleRenderMicrotask() {\n        microtask.render(this.render);\n    }\n}\n\nexport { VisualElement };\n","import { isBrowser } from '../is-browser.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addEventListener(\"change\", setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\nexport { initPrefersReducedMotion };\n","import { isMotionValue, motionValue } from 'motion-dom';\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nexport { updateMotionValuesFromProps };\n","import { DOMKeyframesResolver, isMotionValue } from 'motion-dom';\nimport { VisualElement } from '../VisualElement.mjs';\n\nclass DOMVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style\n            ? props.style[key]\n            : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n\nexport { DOMVisualElement };\n","/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nexport { getValueAsType };\n","import { transformPropOrder, getValueAsType, numberValueTypes } from 'motion-dom';\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nexport { buildTransform };\n","import { transformProps, isCSSVariableName, getValueAsType, numberValueTypes } from 'motion-dom';\nimport { buildTransform } from './build-transform.mjs';\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nexport { buildHTMLStyles };\n","function renderHTML(element, { style, vars }, styleProp, projection) {\n    const elementStyle = element.style;\n    let key;\n    for (key in style) {\n        // CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.\n        elementStyle[key] = style[key];\n    }\n    // Write projection styles directly to element style\n    projection?.applyProjectionStyles(elementStyle, styleProp);\n    for (key in vars) {\n        // Loop over any CSS variables and assign those.\n        // They can only be assigned using `setProperty`.\n        elementStyle.setProperty(key, vars[key]);\n    }\n}\n\nexport { renderHTML };\n","import { isCSSVariableName } from 'motion-dom';\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key];\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true;\n        }\n    }\n}\n\nexport { addScaleCorrector, scaleCorrectors };\n","import { transformProps } from 'motion-dom';\nimport { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nexport { isForcedMotionValue };\n","import { isMotionValue } from 'motion-dom';\nimport { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            visualElement?.getValue(key)?.liveStyle !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n","import { transformProps, defaultTransformValue, readTransformValue, isCSSVariableName } from 'motion-dom';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"html\";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            return this.projection?.isProjecting\n                ? defaultTransformValue(key)\n                : readTransformValue(instance, key);\n        }\n        else {\n            const computedStyle = getComputedStyle(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n}\n\nexport { HTMLVisualElement, getComputedStyle };\n","/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\n\nexport { camelToDash };\n","import { px } from 'motion-dom';\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\nexport { buildSVGPath };\n","import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\nimport { buildSVGPath } from './path.mjs';\n\n/**\n * Build SVG visual attributes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate, styleProp) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style } = state;\n    /**\n     * However, we apply transforms as CSS transforms.\n     * So if we detect a transform, transformOrigin we take it from attrs and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    if (style.transform || attrs.transformOrigin) {\n        style.transformOrigin = attrs.transformOrigin ?? \"50% 50%\";\n        delete attrs.transformOrigin;\n    }\n    if (style.transform) {\n        /**\n         * SVG's element transform-origin uses its own median as a reference.\n         * Therefore, transformBox becomes a fill-box\n         */\n        style.transformBox = styleProp?.transformBox ?? \"fill-box\";\n        delete attrs.transformBox;\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nexport { buildSVGAttrs };\n","/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nexport { camelCaseAttributes };\n","const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nexport { isSVGTag };\n","import { isMotionValue, transformPropOrder } from 'motion-dom';\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n","import { transformProps, getDefaultValueType } from 'motion-dom';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\nimport { camelToDash } from '../dom/utils/camel-to-dash.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { camelCaseAttributes } from './utils/camel-case-attrs.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\nimport { renderSVG } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"svg\";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\nexport { SVGVisualElement };\n","import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';\nimport { renderHTML } from '../../html/utils/render.mjs';\nimport { camelCaseAttributes } from './camel-case-attrs.mjs';\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nexport { renderSVG };\n","/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nexport { lowercaseSVGElements };\n","import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nexport { isSVGComponent };\n","import { Fragment } from 'react';\nimport { HTMLVisualElement } from '../html/HTMLVisualElement.mjs';\nimport { SVGVisualElement } from '../svg/SVGVisualElement.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\n\nconst createDomVisualElement = (Component, options) => {\n    return isSVGComponent(Component)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n            allowProjection: Component !== Fragment,\n        });\n};\n\nexport { createDomVisualElement };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LazyContext = createContext({ strict: false });\n\nexport { LazyContext };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst MotionContext = /* @__PURE__ */ createContext({});\n\nexport { MotionContext };\n","import { useContext, useMemo } from 'react';\nimport { MotionContext } from './index.mjs';\nimport { getCurrentTreeVariants } from './utils.mjs';\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\nexport { useCreateMotionContext };\n","import { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\nimport { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nexport { getCurrentTreeVariants };\n","const createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\nexport { createHtmlRenderState };\n","import { isMotionValue } from 'motion-dom';\nimport { useMemo } from 'react';\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\nexport { copyRawValuesOnly, useHTMLProps };\n","import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\nexport { createSvgRenderState };\n","import { useMemo } from 'react';\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\nexport { useSVGProps };\n","/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith(\"while\") ||\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\n        key.startsWith(\"layout\") ||\n        key.startsWith(\"onTap\") ||\n        key.startsWith(\"onPan\") ||\n        key.startsWith(\"onLayout\") ||\n        validMotionProps.has(key));\n}\n\nexport { isValidMotionProp };\n","import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (typeof isValidProp !== \"function\")\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n}\ncatch {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === \"values\" && typeof props.values === \"object\")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props[\"draggable\"] &&\n                key.startsWith(\"onDrag\"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\nexport { filterProps, loadExternalIsValidProp };\n","import { isMotionValue } from 'motion-dom';\nimport { Fragment, useMemo, createElement } from 'react';\nimport { useHTMLProps } from '../html/use-props.mjs';\nimport { useSVGProps } from '../svg/use-props.mjs';\nimport { filterProps } from './utils/filter-props.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\n\nfunction useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = false) {\n    const useVisualProps = isSVGComponent(Component)\n        ? useSVGProps\n        : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = Component !== Fragment ? { ...filteredProps, ...visualProps, ref } : {};\n    /**\n     * If component has been handed a motion value as its child,\n     * memoise its initial value and render that. Subsequent updates\n     * will be handled by the onChange handler\n     */\n    const { children } = props;\n    const renderedChildren = useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\n    return createElement(Component, {\n        ...elementProps,\n        children: renderedChildren,\n    });\n}\n\nexport { useRender };\n","import { isMotionValue } from 'motion-dom';\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    return isMotionValue(value) ? value.get() : value;\n}\n\nexport { resolveMotionValue };\n","import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    return state;\n}\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\n\nexport { makeUseVisualState };\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nconst useHTMLVisualState = /*@__PURE__*/ makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState,\n});\n\nexport { useHTMLVisualState };\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nconst useSVGVisualState = /*@__PURE__*/ makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    createRenderState: createSvgRenderState,\n});\n\nexport { useSVGVisualState };\n","const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\nexport { motionComponentSymbol };\n","function isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\nexport { isRefObject };\n","import { useCallback } from 'react';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return useCallback((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\nexport { useMotionRef };\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = createContext({});\n\nexport { SwitchLayoutGroupContext };\n","import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement =\n        createVisualElement ||\n            lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n        window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        visualElement.scheduleRenderMicrotask();\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n        /**\n         * Now we've finished triggering animations for this element we\n         * can wipe the enteringChildren set for the next render.\n         */\n        visualElement.enteringChildren = undefined;\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n","\"use client\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { useRender } from '../render/dom/use-render.mjs';\nimport { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';\nimport { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';\nimport { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    const useVisualState = isSVGComponent(Component)\n        ? useSVGVisualState\n        : useHTMLVisualState;\n    function MotionDOMComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));\n    }\n    MotionDOMComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${Component.displayName ?? Component.name ?? \"\"})`}`;\n    const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? warning(false, strictMessage, \"lazy-strict-mode\")\n            : invariant(false, strictMessage, \"lazy-strict-mode\");\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\nexport { createMotionComponent };\n","import { featureDefinitions } from './definitions.mjs';\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\nexport { loadFeatures };\n","import { warnOnce } from 'motion-utils';\nimport { createMotionComponent } from '../../motion/index.mjs';\n\nfunction createMotionProxy(preloadedFeatures, createVisualElement) {\n    if (typeof Proxy === \"undefined\") {\n        return createMotionComponent;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    const componentCache = new Map();\n    const factory = (Component, options) => {\n        return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);\n    };\n    /**\n     * Support for deprecated`motion(Component)` pattern\n     */\n    const deprecatedFactoryFunction = (Component, options) => {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\n        }\n        return factory(Component, options);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: (_target, key) => {\n            if (key === \"create\")\n                return factory;\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, createMotionComponent(key, undefined, preloadedFeatures, createVisualElement));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\nexport { createMotionProxy };\n","import { resolveVariantFromProps } from './resolve-variants.mjs';\n\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\n\nexport { resolveVariant };\n","function getValueTransition(transition, key) {\n    return (transition?.[key] ??\n        transition?.[\"default\"] ??\n        transition);\n}\n\nexport { getValueTransition };\n","const isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nexport { isKeyframesTarget };\n","import { motionValue } from 'motion-dom';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction resolveFinalValueInKeyframes(v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n\nexport { setTarget };\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { isWillChangeMotionValue } from './is.mjs';\n\nfunction addValueToWillChange(visualElement, key) {\n    const willChange = visualElement.getValue(\"willChange\");\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can't add the value to it.\n     */\n    if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key);\n    }\n    else if (!willChange && MotionGlobalConfig.WillChange) {\n        const newWillChange = new MotionGlobalConfig.WillChange(\"auto\");\n        visualElement.addValue(\"willChange\", newWillChange);\n        newWillChange.add(key);\n    }\n}\n\nexport { addValueToWillChange };\n","import { isMotionValue } from 'motion-dom';\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\nexport { isWillChangeMotionValue };\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\nexport { getOptimisedAppearId };\n","function makeAnimationInstant(options) {\n    options.duration = 0;\n    options.type === \"keyframes\";\n}\n\nexport { makeAnimationInstant };\n","/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nexport { pipe };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n","const activeAnimations = {\n    layout: 0,\n    mainThread: 0,\n    waapi: 0,\n};\n\nexport { activeAnimations };\n","// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nexport { hslaToRgba };\n","function mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\nexport { mixImmediate };\n","import { warning } from 'motion-utils';\nimport { hex } from '../../value/types/color/hex.mjs';\nimport { hsla } from '../../value/types/color/hsla.mjs';\nimport { hslaToRgba } from '../../value/types/color/hsla-to-rgba.mjs';\nimport { rgba } from '../../value/types/color/rgba.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber } from './number.mjs';\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`, \"color-not-animatable\");\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\nexport { invisibleValues, mixVisibility };\n","import { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = origin.values[originIndex] ?? 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, \"complex-values-different\");\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n","import { getMixer } from './complex.mjs';\nimport { mixNumber } from './number.mjs';\n\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" &&\n        typeof to === \"number\" &&\n        typeof p === \"number\") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\nexport { mix };\n","import { time } from '../../frameloop/sync-time.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\nexport { frameloopDriver };\n","const generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += Math.round(easing(i / (numPoints - 1)) * 10000) / 10000 + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nexport { generateLinearEasing };\n","/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nexport { calcGeneratorDuration, maxGeneratorDuration };\n","import { velocityPerSecond } from 'motion-utils';\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n","const springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\nexport { springDefaults };\n","import { warning, secondsToMilliseconds, clamp, millisecondsToSeconds } from 'motion-utils';\nimport { springDefaults } from './defaults.mjs';\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\", \"spring-duration-limit\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring };\n","import { millisecondsToSeconds, secondsToMilliseconds, clamp } from 'motion-utils';\nimport { generateLinearEasing } from '../../waapi/utils/linear.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';\nimport { createGeneratorEasing } from '../utils/create-generator-easing.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = t === 0 ? initialVelocity : 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n        toTransition: () => { },\n    };\n    return generator;\n}\nspring.applyToOptions = (options) => {\n    const generatorOptions = createGeneratorEasing(options, 100, spring);\n    options.ease = generatorOptions.ease;\n    options.duration = secondsToMilliseconds(generatorOptions.duration);\n    options.type = \"keyframes\";\n    return options;\n};\n\nexport { spring };\n","import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n","import { millisecondsToSeconds } from 'motion-utils';\nimport { calcGeneratorDuration, maxGeneratorDuration } from './calc-duration.mjs';\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => {\n            return generator.next(duration * progress).value / scale;\n        },\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\nexport { createGeneratorEasing };\n","import { noop } from '../noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticeably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { cubicBezier } from './cubic-bezier.mjs';\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\nexport { easeIn, easeInOut, easeOut };\n","// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nexport { mirrorEasing };\n","// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nexport { reverseEasing };\n","import { cubicBezier } from './cubic-bezier.mjs';\nimport { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\nexport { backIn, backInOut, backOut };\n","import { backIn } from './back.mjs';\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nexport { anticipate };\n","import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\nexport { circIn, circInOut, circOut };\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nexport { isBezierDefinition };\n","import { invariant } from '../../errors.mjs';\nimport { noop } from '../../noop.mjs';\nimport { anticipate } from '../anticipate.mjs';\nimport { backIn, backInOut, backOut } from '../back.mjs';\nimport { circIn, circInOut, circOut } from '../circ.mjs';\nimport { cubicBezier } from '../cubic-bezier.mjs';\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\nimport { isBezierDefinition } from './is-bezier-definition.mjs';\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst isValidEasing = (easing) => {\n    return typeof easing === \"string\";\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, \"cubic-bezier-length\");\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (isValidEasing(definition)) {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`, \"invalid-easing-type\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nexport { easingDefinitionToFunction };\n","/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n","import { invariant, clamp, MotionGlobalConfig, noop, pipe, progress } from 'motion-utils';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\", \"range-length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n","import { fillOffset } from './fill.mjs';\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nexport { defaultOffset };\n","import { progress } from 'motion-utils';\nimport { mixNumber } from '../../../utils/mix/number.mjs';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\nexport { fillOffset };\n","import { easeInOut, isEasingArray, easingDefinitionToFunction } from 'motion-utils';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../keyframes/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../keyframes/offsets/time.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","const isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { isEasingArray };\n","function convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nexport { convertOffsetToTimes };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe, speed = 1) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const useFirstKeyframe = speed < 0 || (repeat && repeatType !== \"loop\" && repeat % 2 === 1);\n    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","import { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\n\nconst transitionTypeMap = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nfunction replaceTransitionType(transition) {\n    if (typeof transition.type === \"string\") {\n        transition.type = transitionTypeMap[transition.type];\n    }\n}\n\nexport { replaceTransitionType };\n","class WithPromise {\n    constructor() {\n        this.updateFinished();\n    }\n    get finished() {\n        return this._finished;\n    }\n    updateFinished() {\n        this._finished = new Promise((resolve) => {\n            this.resolve = resolve;\n        });\n    }\n    notifyFinished() {\n        this.resolve();\n    }\n    /**\n     * Allows the animation to be awaited.\n     *\n     * @deprecated Use `finished` instead.\n     */\n    then(onResolve, onReject) {\n        return this.finished.then(onResolve, onReject);\n    }\n}\n\nexport { WithPromise };\n","import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/frame.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            this.options.onStop?.();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, \"spring-two-frames\");\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n        this.driver?.start(false);\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        this.options.onPlay?.();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.notifyFinished();\n        this.teardown();\n        this.state = \"finished\";\n        this.options.onComplete?.();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n        this.options.onCancel?.();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        this.driver?.stop();\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n","import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {};\n\nexport { supportsFlags };\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => supportsFlags[supportsFlag] ?? memoized();\n}\n\nexport { memoSupports };\n","import { memoSupports } from './memo.mjs';\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nexport { supportsLinearEasing };\n","const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { cubicBezierAsString };\n","import { cubicBezierAsString } from './cubic-bezier.mjs';\n\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\n\nexport { supportedWaapiEasing };\n","import { isBezierDefinition } from 'motion-utils';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { generateLinearEasing } from '../utils/linear.mjs';\nimport { cubicBezierAsString } from './cubic-bezier.mjs';\nimport { supportedWaapiEasing } from './supported.mjs';\n\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\") {\n        return supportsLinearEasing()\n            ? generateLinearEasing(easing, duration)\n            : \"ease-out\";\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nexport { mapEasingToNativeEasing };\n","import { activeAnimations } from '../../stats/animation-count.mjs';\nimport { statsBuffer } from '../../stats/buffer.mjs';\nimport { mapEasingToNativeEasing } from './easing/map-easing.mjs';\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeOut\", times, } = {}, pseudoElement = undefined) {\n    const keyframeOptions = {\n        [valueName]: keyframes,\n    };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    if (statsBuffer.value) {\n        activeAnimations.waapi++;\n    }\n    const options = {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    };\n    if (pseudoElement)\n        options.pseudoElement = pseudoElement;\n    const animation = element.animate(keyframeOptions, options);\n    if (statsBuffer.value) {\n        animation.finished.finally(() => {\n            activeAnimations.waapi--;\n        });\n    }\n    return animation;\n}\n\nexport { startWaapiAnimation };\n","function isGenerator(type) {\n    return typeof type === \"function\" && \"applyToOptions\" in type;\n}\n\nexport { isGenerator };\n","import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.finishedTime = null;\n        this.isStopped = false;\n        if (!options)\n            return;\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        this.options = options;\n        invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n        const transition = applyGeneratorOptions(options);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time;\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe);\n                }\n                else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe);\n                }\n                this.animation.cancel();\n            }\n            onComplete?.();\n            this.notifyFinished();\n        };\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        this.animation.play();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n        }\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish?.();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        if (this.updateMotionValue) {\n            this.updateMotionValue();\n        }\n        else {\n            this.commitStyles();\n        }\n        if (!this.isPseudoElement)\n            this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.finishedTime = null;\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0)\n            this.finishedTime = null;\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState;\n    }\n    get startTime() {\n        return Number(this.animation.startTime);\n    }\n    set startTime(newStartTime) {\n        this.animation.startTime = newStartTime;\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }) {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n        this.animation.onfinish = null;\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline;\n            return noop;\n        }\n        else {\n            return observe(this);\n        }\n    }\n}\n\nexport { NativeAnimation };\n","import { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\n\nfunction applyGeneratorOptions({ type, ...options }) {\n    if (isGenerator(type) && supportsLinearEasing()) {\n        return type.applyToOptions(options);\n    }\n    else {\n        options.duration ?? (options.duration = 300);\n        options.ease ?? (options.ease = \"easeOut\");\n    }\n    return options;\n}\n\nexport { applyGeneratorOptions };\n","import { isCSSVar } from './is-css-var.mjs';\n\nfunction setStyle(element, name, value) {\n    isCSSVar(name)\n        ? element.style.setProperty(name, value)\n        : (element.style[name] = value);\n}\n\nexport { setStyle };\n","const isCSSVar = (name) => name.startsWith(\"--\");\n\nexport { isCSSVar };\n","import { anticipate, backInOut, circInOut } from 'motion-utils';\n\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nfunction replaceStringEasing(transition) {\n    if (typeof transition.ease === \"string\" &&\n        isUnsupportedEase(transition.ease)) {\n        transition.ease = unsupportedEasingFunctions[transition.ease];\n    }\n}\n\nexport { replaceStringEasing };\n","import { secondsToMilliseconds } from 'motion-utils';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { NativeAnimation } from './NativeAnimation.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { replaceStringEasing } from './waapi/utils/unsupported-easing.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\nclass NativeAnimationExtended extends NativeAnimation {\n    constructor(options) {\n        /**\n         * The base NativeAnimation function only supports a subset\n         * of Motion easings, and WAAPI also only supports some\n         * easing functions via string/cubic-bezier definitions.\n         *\n         * This function replaces those unsupported easing functions\n         * with a JS easing function. This will later get compiled\n         * to a linear() easing function.\n         */\n        replaceStringEasing(options);\n        /**\n         * Ensure we replace the transition type with a generator function\n         * before passing to WAAPI.\n         *\n         * TODO: Does this have a better home? It could be shared with\n         * JSAnimation.\n         */\n        replaceTransitionType(options);\n        super(options);\n        if (options.startTime) {\n            this.startTime = options.startTime;\n        }\n        this.options = options;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    updateMotionValue(value) {\n        const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n        if (!motionValue)\n            return;\n        if (value !== undefined) {\n            motionValue.set(value);\n            return;\n        }\n        const sampleAnimation = new JSAnimation({\n            ...options,\n            autoplay: false,\n        });\n        const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        sampleAnimation.stop();\n    }\n}\n\nexport { NativeAnimationExtended };\n","import { complex } from '../../value/types/complex/index.mjs';\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys that might be non-animatable grows, replace with Set\n    if (name === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nexport { isAnimatable };\n","import { memo } from 'motion-utils';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Could be re-enabled now we have support for linear() easing\n    // \"background-color\"\n]);\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\nfunction supportsBrowserAnimation(options) {\n    const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n    const subject = motionValue?.owner?.current;\n    /**\n     * We use this check instead of isHTMLElement() because we explicitly\n     * **don't** want elements in different timing contexts (i.e. popups)\n     * to be accelerated, as it's not possible to sync these animations\n     * properly with those driven from the main window frameloop.\n     */\n    if (!(subject instanceof HTMLElement)) {\n        return false;\n    }\n    const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n    return (supportsWaapi() &&\n        name &&\n        acceleratedValues.has(name) &&\n        (name !== \"transform\" || !transformTemplate) &&\n        /**\n         * If we're outputting values to onUpdate then we can't use WAAPI as there's\n         * no way to read the value from WAAPI every frame.\n         */\n        !onUpdate &&\n        !repeatDelay &&\n        repeatType !== \"mirror\" &&\n        damping !== 0 &&\n        type !== \"inertia\");\n}\n\nexport { supportsBrowserAnimation };\n","import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            this.keyframeResolver?.cancel();\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            makeAnimationInstant(options);\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            this.keyframeResolver?.resume();\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel();\n        }\n        this.keyframeResolver?.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n","import { warning } from 'motion-utils';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren't traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === \"display\" || name === \"visibility\")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". \"${isOriginAnimatable ? targetKeyframe : originKeyframe}\" is not an animatable value.`, \"value-not-animatable\");\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === \"spring\" || isGenerator(type)) && velocity));\n}\n\nexport { canAnimate };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","import { transformProps } from 'motion-dom';\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\nexport { getDefaultTransition };\n","import { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        makeAnimationInstant(options);\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (MotionGlobalConfig.instantAnimations ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        makeAnimationInstant(options);\n        options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            return;\n        }\n    }\n    return valueTransition.isSync\n        ? new JSAnimation(options)\n        : new AsyncMotionValueAnimation(options);\n};\n\nexport { animateMotionValue };\n","/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\nexport { isTransitionDefined };\n","import { getValueTransition, frame, positionalKeys } from 'motion-dom';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If the value is already at the defined target, skip the animation.\n         */\n        const currentValue = value.get();\n        if (currentValue !== undefined &&\n            !value.isAnimating &&\n            !Array.isArray(valueTarget) &&\n            valueTarget === currentValue &&\n            !valueTransition.velocity) {\n            continue;\n        }\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n","function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {\n    const index = Array.from(children)\n        .sort((a, b) => a.sortNodePosition(b))\n        .indexOf(child);\n    const numChildren = children.size;\n    const maxStaggerDuration = (numChildren - 1) * staggerChildren;\n    const delayIsFunction = typeof delayChildren === \"function\";\n    return delayIsFunction\n        ? delayChildren(index, numChildren)\n        : staggerDirection === 1\n            ? index * staggerChildren\n            : maxStaggerDuration - index * staggerChildren;\n}\n\nexport { calcChildStagger };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { calcChildStagger } from '../utils/calc-child-stagger.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? visualElement.presenceContext?.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delay = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    for (const child of visualElement.variantChildren) {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delay +\n                (typeof delayChildren === \"function\" ? 0 : delayChildren) +\n                calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    }\n    return Promise.all(animations);\n}\n\nexport { animateVariant };\n","function shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nexport { shallowCompare };\n","import { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement)\n        return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent\n            ? getVariantContext(visualElement.parent) || {}\n            : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\n\nexport { getVariantContext };\n","import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { calcChildStagger } from '../../animation/utils/calc-child-stagger.mjs';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => {\n                    const options = { type };\n                    /**\n                     * If we're performing the initial animation, but we're not\n                     * rendering at the same time as the variant-controlling parent,\n                     * we want to use the parent's transition to calculate the stagger.\n                     */\n                    if (typeof animation === \"string\" &&\n                        isInitialRender &&\n                        !willAnimateViaParent &&\n                        visualElement.manuallyAnimateOnMount &&\n                        visualElement.parent) {\n                        const { parent } = visualElement;\n                        const parentVariant = resolveVariant(parent, animation);\n                        if (parent.enteringChildren && parentVariant) {\n                            const { delayChildren } = parentVariant.transition || {};\n                            options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);\n                        }\n                    }\n                    return {\n                        animation: animation,\n                        options,\n                    };\n                }));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\n                    ? props.initial[0]\n                    : props.initial);\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition;\n                }\n            }\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget ?? null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nimport { animateVariant } from './visual-element-variant.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify(\"AnimationComplete\", definition);\n    });\n}\n\nexport { animateVisualElement };\n","class Feature {\n    constructor(node) {\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() { }\n}\n\nexport { Feature };\n","import { Feature } from '../Feature.mjs';\n\nlet id = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.id = id++;\n    }\n    update() {\n        if (!this.node.presenceContext)\n            return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => {\n                onExitComplete(this.id);\n            });\n        }\n    }\n    mount() {\n        const { register, onExitComplete } = this.node.presenceContext || {};\n        if (onExitComplete) {\n            onExitComplete(this.id);\n        }\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() { }\n}\n\nexport { ExitAnimationFeature };\n","import { AnimationFeature } from './animation/index.mjs';\nimport { ExitAnimationFeature } from './animation/exit.mjs';\n\nconst animations = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n};\n\nexport { animations };\n","import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';\nimport { createAnimationState } from '../../../render/utils/animation-state.mjs';\nimport { Feature } from '../Feature.mjs';\n\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node) {\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        this.node.animationState.reset();\n        this.unmountControls?.();\n    }\n}\n\nexport { AnimationFeature };\n","const isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\nexport { isDragActive, isDragging };\n","function addDomEvent(target, eventName, handler, options = { passive: true }) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n}\n\nexport { addDomEvent };\n","const isPrimaryPointer = (event) => {\n    if (event.pointerType === \"mouse\") {\n        return typeof event.button !== \"number\" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\nexport { isPrimaryPointer };\n","import { isPrimaryPointer } from 'motion-dom';\n\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    };\n}\nconst addPointerInfo = (handler) => {\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\nexport { addPointerInfo, extractEventInfo };\n","import { addDomEvent } from './add-dom-event.mjs';\nimport { addPointerInfo } from './event-info.mjs';\n\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\nexport { addPointerEvent };\n","import { mixNumber } from 'motion-dom';\n\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate =\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\n        isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if ((delta.translate >= TRANSLATE_MIN &&\n        delta.translate <= TRANSLATE_MAX) ||\n        isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\nexport { calcAxisDelta, calcBoxDelta, calcLength, calcRelativeAxis, calcRelativeAxisPosition, calcRelativeBox, calcRelativePosition, isNear };\n","function eachAxis(callback) {\n    return [callback(\"x\"), callback(\"y\")];\n}\n\nexport { eachAxis };\n","// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = ({ current }) => {\n    return current ? current.ownerDocument.defaultView : null;\n};\n\nexport { getContextWindow };\n","const distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nexport { distance, distance2D };\n","import { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursor.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.distanceThreshold = distanceThreshold;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n","import { mixNumber } from 'motion-dom';\nimport { progress, clamp } from 'motion-utils';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n","import { frame, mixNumber, setDragLock, percent } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { PanSession } from '../pan/PanSession.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\n\nconst elementDragControls = new WeakMap();\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        /**\n         * The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n         */\n        this.latestPointerEvent = null;\n        /**\n         * The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n         */\n        this.latestPanInfo = null;\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = setDragLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.latestPointerEvent = event;\n            this.latestPanInfo = info;\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, \"transform\");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive(\"whileDrag\", true);\n        };\n        const onMove = (event, info) => {\n            this.latestPointerEvent = event;\n            this.latestPanInfo = info;\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset);\n            this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => {\n            this.latestPointerEvent = event;\n            this.latestPanInfo = info;\n            this.stop(event, info);\n            this.latestPointerEvent = null;\n            this.latestPanInfo = null;\n        };\n        const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === \"paused\" &&\n            this.getAxisMotionValue(axis).animation?.play());\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            distanceThreshold,\n            contextWindow: getContextWindow(this.visualElement),\n        });\n    }\n    /**\n     * @internal\n     */\n    stop(event, panInfo) {\n        const finalEvent = event || this.latestPointerEvent;\n        const finalPanInfo = panInfo || this.latestPanInfo;\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging || !finalPanInfo || !finalEvent)\n            return;\n        const { velocity } = finalPanInfo;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));\n        }\n    }\n    /**\n     * @internal\n     */\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive(\"whileDrag\", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : this.visualElement.projection?.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\", \"drag-constraints-ref\");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());\n    }\n    getAnimationState(axis) {\n        return this.getAxisMotionValue(axis).animation?.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n","import { isDragging } from './is-active.mjs';\n\nfunction setDragLock(axis) {\n    if (axis === \"x\" || axis === \"y\") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\nexport { setDragLock };\n","import { frame } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { Feature } from '../../motion/features/Feature.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { PanSession } from './PanSession.mjs';\n\nconst asyncHandler = (handler) => (event, info) => {\n    if (handler) {\n        frame.postRender(() => handler(event, info));\n    }\n};\nclass PanGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.removePointerDownListener = noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n            contextWindow: getContextWindow(this.node),\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info) => {\n                delete this.session;\n                if (onPanEnd) {\n                    frame.postRender(() => onPanEnd(event, info));\n                }\n            },\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\n\nexport { PanGesture };\n","/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nconst globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\nexport { globalProjectionState };\n","import { px } from 'motion-dom';\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\nexport { correctBorderRadius, pixelsToPercent };\n","import { complex, mixNumber } from 'motion-dom';\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\nexport { correctBoxShadow };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { frame, microtask } from 'motion-dom';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false;\nclass MeasureLayoutWithContext extends Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            if (hasTakenAnySnapshot) {\n                projection.root.didUpdate();\n            }\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const { projection } = visualElement;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        hasTakenAnySnapshot = true;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined ||\n            prevProps.isPresent !== isPresent) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        hasTakenAnySnapshot = true;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an SVG element in a way\n * that works across iframes\n */\nfunction isSVGElement(element) {\n    return isObject(element) && \"ownerSVGElement\" in element;\n}\n\nexport { isSVGElement };\n","const compareByDepth = (a, b) => a.depth - b.depth;\n\nexport { compareByDepth };\n","import { addUniqueItem, removeItem } from 'motion-utils';\nimport { compareByDepth } from './compare-by-depth.mjs';\n\nclass FlatTree {\n    constructor() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n\nexport { FlatTree };\n","import { time, frame, cancelFrame } from 'motion-dom';\nimport { secondsToMilliseconds } from 'motion-utils';\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.setup(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\nfunction delayInSeconds(callback, timeout) {\n    return delay(callback, secondsToMilliseconds(timeout));\n}\n\nexport { delay, delayInSeconds };\n","import { mixNumber, percent, px } from 'motion-dom';\nimport { progress, circOut, noop } from 'motion-utils';\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n","/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n\nexport { copyAxisDeltaInto, copyAxisInto, copyBoxInto };\n","import { percent, mixNumber } from 'motion-dom';\nimport { scalePoint } from './delta-apply.mjs';\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\")\n        return;\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };\n","import { calcLength } from './delta-calc.mjs';\n\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return (Math.round(a.min) === Math.round(b.min) &&\n        Math.round(a.max) === Math.round(b.max));\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return (a.translate === b.translate &&\n        a.scale === b.scale &&\n        a.originPoint === b.originPoint);\n}\n\nexport { aspectRatio, axisDeltaEquals, axisEquals, axisEqualsRounded, boxEquals, boxEqualsRounded, isDeltaZero };\n","import { addUniqueItem, removeItem } from 'motion-utils';\n\nclass NodeStack {\n    constructor() {\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member) => node === member);\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        let prevLead;\n        for (let i = indexOfNode; i >= 0; i--) {\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node) => {\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete &&\n                    resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node) => {\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\n\nexport { NodeStack };\n","import { statsBuffer, isSVGElement, isSVGSVGElement, frame, getValueTransition, cancelFrame, time, frameData, frameSteps, microtask, activeAnimations, motionValue, mixNumber } from 'motion-dom';\nimport { SubscriptionManager, clamp, noop } from 'motion-utils';\nimport { animateSingleValue } from '../../animation/animate/single-value.mjs';\nimport { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\nimport { delay } from '../../utils/delay.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { mixValues } from '../animation/mix-values.mjs';\nimport { copyBoxInto, copyAxisDeltaInto } from '../geometry/copy.mjs';\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\nimport { calcLength, calcRelativePosition, calcRelativeBox, calcBoxDelta, isNear } from '../geometry/delta-calc.mjs';\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\nimport { createBox, createDelta } from '../geometry/models.mjs';\nimport { boxEqualsRounded, isDeltaZero, axisDeltaEquals, aspectRatio, boxEquals } from '../geometry/utils.mjs';\nimport { NodeStack } from '../shared/stack.mjs';\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\nimport { buildProjectionTransform } from '../styles/transform.mjs';\nimport { eachAxis } from '../utils/each-axis.mjs';\nimport { hasTransform, hasScale, has2DTranslate } from '../utils/has-transform.mjs';\nimport { globalProjectionState } from './state.mjs';\n\nconst metrics = {\n    nodes: 0,\n    calculatedTargetDeltas: 0,\n    calculatedProjections: 0,\n};\nconst transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nconst animationTarget = 1000;\nlet id = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode)\n        return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement)\n        return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent?.()) {\n            /**\n             * A unique ID generated for every projection node.\n             */\n            this.id = id++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */\n            this.animationId = 0;\n            this.animationCommitId = 0;\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */\n            this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */\n            this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */\n            this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */\n            this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = () => this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = () => {\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */\n            this.updateProjection = () => {\n                this.projectionUpdateScheduled = false;\n                /**\n                 * Reset debug counts. Manually resetting rather than creating a new\n                 * object each frame.\n                 */\n                if (statsBuffer.value) {\n                    metrics.nodes =\n                        metrics.calculatedTargetDeltas =\n                            metrics.calculatedProjections =\n                                0;\n                }\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n                if (statsBuffer.addProjectionMetrics) {\n                    statsBuffer.addProjectionMetrics(metrics);\n                }\n            };\n            /**\n             * Frame calculations\n             */\n            this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [...parent.path, parent] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for (let i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */\n        mount(instance) {\n            if (this.instance)\n                return;\n            this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (this.root.hasTreeAnimated && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                let innerWidth = 0;\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\n                // Set initial innerWidth in a frame.read callback to batch the read\n                frame.read(() => {\n                    innerWidth = window.innerWidth;\n                });\n                attachResizeListener(instance, () => {\n                    const newInnerWidth = window.innerWidth;\n                    if (newInnerWidth === innerWidth)\n                        return;\n                    innerWidth = newInnerWidth;\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) => {\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition ||\n                        visualElement.getDefaultTransition() ||\n                        defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    const hasTargetChanged = !this.targetLayout ||\n                        !boxEqualsRounded(this.targetLayout, newLayout);\n                    /*\n                     * Note: Disabled to fix relative animations always triggering new\n                     * layout animations. If this causes further issues, we can try\n                     * a different approach to detecting relative target changes.\n                     */\n                    // || hasRelativeLayoutChanged\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\n                    if (this.options.layoutRoot ||\n                        this.resumeFrom ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (hasTargetChanged || !this.currentAnimation))) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        const animationOptions = {\n                            ...getValueTransition(layoutTransition, \"layout\"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete,\n                        };\n                        if (visualElement.shouldReduceMotion ||\n                            this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                        /**\n                         * Set animation origin after starting animation to avoid layout jump\n                         * caused by stopping previous layout animation\n                         */\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            this.eventHandlers.clear();\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return (this.isAnimationBlocked ||\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\n                false);\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we're running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don't yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */\n            if (window.MotionCancelOptimisedAnimation &&\n                !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll(\"snapshot\");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout)\n                return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            /**\n             * If this is a repeat of didUpdate then ignore the animation.\n             */\n            if (this.animationId <= this.animationCommitId) {\n                this.nodes.forEach(clearIsLayoutDirty);\n                return;\n            }\n            this.animationCommitId = this.animationId;\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            else {\n                this.isUpdating = false;\n                /**\n                 * Write\n                 */\n                this.nodes.forEach(resetTransformStyle);\n                /**\n                 * Read ==================\n                 */\n                // Update layout measurements of updated children\n                this.nodes.forEach(updateLayout);\n                /**\n                 * Write\n                 */\n                // Notify listeners that the layout is updated\n                this.nodes.forEach(notifyLayoutUpdate);\n            }\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */\n            const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            frame.postRender(() => {\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                }\n                else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */\n        updateSnapshot() {\n            if (this.snapshot || !this.instance)\n                return;\n            this.snapshot = this.measure();\n            if (this.snapshot &&\n                !calcLength(this.snapshot.measuredBox.x) &&\n                !calcLength(this.snapshot.measuredBox.y)) {\n                this.snapshot = undefined;\n            }\n        }\n        updateLayout() {\n            if (!this.instance)\n                return;\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (let i = 0; i < this.path.length; i++) {\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement &&\n                visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = \"measure\") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll &&\n                this.scroll.animationId === this.root.animationId &&\n                this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement && this.instance) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform)\n                return;\n            const isResetRequested = this.isLayoutDirty ||\n                this.shouldResetTransform ||\n                this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                this.instance &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */\n            if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id,\n            };\n        }\n        measurePageBox() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if (this.scroll?.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent)\n                return;\n            /**\n             * If the parent target isn't up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */\n            if (this.relativeParent.resolvedRelativeTargetAt !==\n                frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */\n            const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don't use transform for this step of processing so we don't\n             * need to check whether any nodes have changed transform.\n             */\n            const canSkip = !(forceRecalculation ||\n                (isShared && this.isSharedProjectionDirty) ||\n                this.isProjectionDirty ||\n                this.parent?.isProjectionDirty ||\n                this.attemptToResolveRelativeTarget ||\n                this.root.updateBlockedByResize);\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    relativeParent.layout &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                this.relativeParent &&\n                this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    Boolean(relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !relativeParent.options.layoutScroll &&\n                    relativeParent.target &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * Increase debug counter for resolved target deltas\n             */\n            if (statsBuffer.value) {\n                metrics.calculatedTargetDeltas++;\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent ||\n                hasScale(this.parent.latestValues) ||\n                has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget ||\n                this.targetDelta ||\n                this.options.layoutRoot) &&\n                this.layout);\n        }\n        calcProjection() {\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can't skip.\n             */\n            if (this.isProjectionDirty || this.parent?.isProjectionDirty) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node's shared projection is dirty then\n             * we can't skip.\n             */\n            if (isShared &&\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */\n            const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn't have a target,\n             * use the layout as the target.\n             */\n            if (lead.layout &&\n                !lead.target &&\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don't have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */\n                if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            }\n            else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY ||\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n            /**\n             * Increase debug counter for recalculated projections\n             */\n            if (statsBuffer.value) {\n                metrics.calculatedProjections++;\n            }\n        }\n        hide() {\n            this.isVisible = false;\n            // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n            // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            this.options.visualElement?.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot ? snapshot.latestValues : {};\n            const mixedValues = { ...this.latestValues };\n            const targetDelta = createDelta();\n            if (!this.relativeParent ||\n                !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest) => {\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget &&\n                    this.relativeTargetOrigin &&\n                    this.layout &&\n                    this.relativeParent &&\n                    this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */\n                    if (prevRelativeTarget &&\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget)\n                        prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners(\"animationStart\");\n            this.currentAnimation?.stop();\n            this.resumingFrom?.currentAnimation?.stop();\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = frame.update(() => {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                activeAnimations.layout++;\n                this.motionValue || (this.motionValue = motionValue(0));\n                this.currentAnimation = animateSingleValue(this.motionValue, [0, 1000], {\n                    ...options,\n                    velocity: 0,\n                    isSync: true,\n                    onUpdate: (latest) => {\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onStop: () => {\n                        activeAnimations.layout--;\n                    },\n                    onComplete: () => {\n                        activeAnimations.layout--;\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    },\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners(\"animationComplete\");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            /**\n             * If we're only animating position, and this element isn't the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */\n            if (this !== lead &&\n                this.layout &&\n                layout &&\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\n                    ? config.shouldPreserveFollowOpacity(node)\n                    : undefined,\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            const { layoutId } = this.options;\n            return layoutId ? this.getStack()?.lead || this : this;\n        }\n        getPrevLead() {\n            const { layoutId } = this.options;\n            return layoutId ? this.getStack()?.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\n            const stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return;\n            // If there's no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don't have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */\n            const { latestValues } = visualElement;\n            if (latestValues.z ||\n                latestValues.rotate ||\n                latestValues.rotateX ||\n                latestValues.rotateY ||\n                latestValues.rotateZ ||\n                latestValues.skewX ||\n                latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there's no distorting values, we don't need to do any more.\n            if (!hasDistortingTransform)\n                return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for (let i = 0; i < transformAxes.length; i++) {\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for (const key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        applyProjectionStyles(targetStyle, // CSSStyleDeclaration - doesn't allow numbers to be assigned to properties\n        styleProp) {\n            if (!this.instance || this.isSVG)\n                return;\n            if (!this.isVisible) {\n                targetStyle.visibility = \"hidden\";\n                return;\n            }\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                targetStyle.visibility = \"\";\n                targetStyle.opacity = \"\";\n                targetStyle.pointerEvents =\n                    resolveMotionValue(styleProp?.pointerEvents) || \"\";\n                targetStyle.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, \"\")\n                    : \"none\";\n                return;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                if (this.options.layoutId) {\n                    targetStyle.opacity =\n                        this.latestValues.opacity !== undefined\n                            ? this.latestValues.opacity\n                            : 1;\n                    targetStyle.pointerEvents =\n                        resolveMotionValue(styleProp?.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    targetStyle.transform = transformTemplate\n                        ? transformTemplate({}, \"\")\n                        : \"none\";\n                    this.hasProjected = false;\n                }\n                return;\n            }\n            targetStyle.visibility = \"\";\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                transform = transformTemplate(valuesToRender, transform);\n            }\n            targetStyle.transform = transform;\n            const { x, y } = this.projectionDelta;\n            targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                targetStyle.opacity =\n                    lead === this\n                        ? valuesToRender.opacity ??\n                            this.latestValues.opacity ??\n                            1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we're not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */\n                targetStyle.opacity =\n                    lead === this\n                        ? valuesToRender.opacity !== undefined\n                            ? valuesToRender.opacity\n                            : \"\"\n                        : valuesToRender.opacityExit !== undefined\n                            ? valuesToRender.opacityExit\n                            : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (const key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */\n                const corrected = transform === \"none\"\n                    ? valuesToRender[key]\n                    : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for (let i = 0; i < num; i++) {\n                        targetStyle[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    // If this is a CSS variable, set it directly on the instance.\n                    // Replacing this function from creating styles to setting them\n                    // would be a good place to remove per frame object creation\n                    if (isCSSVariable) {\n                        this.options.visualElement.renderState.vars[key] = corrected;\n                    }\n                    else {\n                        targetStyle[key] = corrected;\n                    }\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                targetStyle.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp?.pointerEvents) || \"\"\n                        : \"none\";\n            }\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node) => node.currentAnimation?.stop());\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    const snapshot = node.resumeFrom?.snapshot || node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners(\"didUpdate\")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (animationType === \"size\") {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */\n                if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max =\n                        node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeLayoutChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeLayoutChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeLayoutChanged,\n        });\n    }\n    else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    /**\n     * Increase debug counter for nodes encountered this frame\n     */\n    if (statsBuffer.value) {\n        metrics.nodes++;\n    }\n    if (!node.parent)\n        return;\n    /**\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */\n    if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\n        node.parent.isProjectionDirty ||\n        node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty =\n        node.isSharedProjectionDirty =\n            node.isTransformDirty =\n                false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify(\"BeforeLayoutMeasure\");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber(delta.translate, 0, p);\n    output.scale = mixNumber(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber(from.min, to.min, p);\n    output.max = mixNumber(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nconst userAgentContains = (string) => typeof navigator !== \"undefined\" &&\n    navigator.userAgent &&\n    navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */\nconst roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\")\n    ? Math.round\n    : noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return (animationType === \"position\" ||\n        (animationType === \"preserve-aspect\" &&\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\n}\nfunction checkNodeWasScrollRoot(node) {\n    return node !== node.root && node.scroll?.wasRoot;\n}\n\nexport { cleanDirtyNodes, createProjectionNode, mixAxis, mixAxisDelta, mixBox, propagateDirtyNodes };\n","import { isSVGElement } from './is-svg-element.mjs';\n\n/**\n * Checks if an element is specifically an SVGSVGElement (the root SVG element)\n * in a way that works across iframes\n */\nfunction isSVGSVGElement(element) {\n    return isSVGElement(element) && element.tagName === \"svg\";\n}\n\nexport { isSVGSVGElement };\n","import { isMotionValue, motionValue } from 'motion-dom';\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\nexport { animateSingleValue };\n","function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = latestTransform?.z || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n","import { addDomEvent } from '../../events/add-dom-event.mjs';\nimport { createProjectionNode } from './create-projection-node.mjs';\n\nconst DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n    measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }),\n    checkIsScrollRoot: () => true,\n});\n\nexport { DocumentProjectionNode };\n","import { createProjectionNode } from './create-projection-node.mjs';\nimport { DocumentProjectionNode } from './DocumentProjectionNode.mjs';\n\nconst rootProjectionNode = {\n    current: undefined,\n};\nconst HTMLProjectionNode = createProjectionNode({\n    measureScroll: (instance) => ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }),\n    defaultParent: () => {\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value) => {\n        instance.style.transform = value !== undefined ? value : \"none\";\n    },\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\"),\n});\n\nexport { HTMLProjectionNode, rootProjectionNode };\n","import { DragGesture } from '../../gestures/drag/index.mjs';\nimport { PanGesture } from '../../gestures/pan/index.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\nimport { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\n\nconst drag = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nexport { drag };\n","import { Feature } from '../../motion/features/Feature.mjs';\nimport { noop } from 'motion-utils';\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\n\nclass DragGesture extends Feature {\n    constructor(node) {\n        super(node);\n        this.removeGroupControls = noop;\n        this.removeListeners = noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\n\nexport { DragGesture };\n","import { resolveElements } from '../../utils/resolve-elements.mjs';\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\nexport { setupGesture };\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            root = scope.current;\n        }\n        const elements = selectorCache?.[elementOrSelector] ??\n            root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nexport { resolveElements };\n","import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\n\nfunction isValidHover(event) {\n    return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = (enterEvent) => {\n        if (!isValidHover(enterEvent))\n            return;\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(target, enterEvent);\n        if (typeof onHoverEnd !== \"function\" || !target)\n            return;\n        const onPointerLeave = (leaveEvent) => {\n            if (!isValidHover(leaveEvent))\n                return;\n            onHoverEnd(leaveEvent);\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\n        };\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    };\n    elements.forEach((element) => {\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\nexport { hover };\n","import { hover, frame } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\n\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onHover\" + lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = hover(current, (_element, startEvent) => {\n            handleHoverEvent(this.node, startEvent, \"Start\");\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\");\n        });\n    }\n    unmount() { }\n}\n\nexport { HoverGesture };\n","/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nexport { isNodeOrChild };\n","const focusableElements = new Set([\n    \"BUTTON\",\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\",\n    \"A\",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\nexport { isElementKeyboardAccessible };\n","const isPressing = new WeakSet();\n\nexport { isPressing };\n","import { isPressing } from './state.mjs';\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== \"Enter\")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, \"down\");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n        });\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\n    });\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\nexport { enableKeyboardPress };\n","import { isHTMLElement } from '../../utils/is-html-element.mjs';\nimport { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n    const startPress = (startEvent) => {\n        const target = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent))\n            return;\n        isPressing.add(target);\n        const onPressEnd = onPressStart(target, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener(\"pointerup\", onPointerUp);\n            window.removeEventListener(\"pointercancel\", onPointerCancel);\n            if (isPressing.has(target)) {\n                isPressing.delete(target);\n            }\n            if (!isValidPressEvent(endEvent)) {\n                return;\n            }\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, target === window ||\n                target === document ||\n                options.useGlobalTarget ||\n                isNodeOrChild(target, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    };\n    targets.forEach((target) => {\n        const pointerDownTarget = options.useGlobalTarget ? window : target;\n        pointerDownTarget.addEventListener(\"pointerdown\", startPress, eventOptions);\n        if (isHTMLElement(target)) {\n            target.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions));\n            if (!isElementKeyboardAccessible(target) &&\n                !target.hasAttribute(\"tabindex\")) {\n                target.tabIndex = 0;\n            }\n        }\n    });\n    return cancelEvents;\n}\n\nexport { press };\n","import { press, frame } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\n\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.current instanceof HTMLButtonElement && node.current.disabled) {\n        return;\n    }\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle));\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = press(current, (_element, startEvent) => {\n            handlePressEvent(this.node, startEvent, \"Start\");\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\n    }\n    unmount() { }\n}\n\nexport { PressGesture };\n","/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n","import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n","import { HoverGesture } from '../../gestures/hover.mjs';\nimport { FocusGesture } from '../../gestures/focus.mjs';\nimport { PressGesture } from '../../gestures/press.mjs';\nimport { InViewFeature } from './viewport/index.mjs';\n\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n};\n\nexport { gestureAnimations };\n","import { createDomVisualElement } from '../../dom/create-visual-element.mjs';\nimport { createMotionProxy } from '../create-proxy.mjs';\nimport { featureBundle } from './feature-bundle.mjs';\n\nconst motion = /*@__PURE__*/ createMotionProxy(featureBundle, createDomVisualElement);\n\nexport { motion };\n","import { animations } from '../../../motion/features/animations.mjs';\nimport { drag } from '../../../motion/features/drag.mjs';\nimport { gestureAnimations } from '../../../motion/features/gestures.mjs';\nimport { layout } from '../../../motion/features/layout.mjs';\n\nconst featureBundle = {\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n};\n\nexport { featureBundle };\n","import { pipe } from 'motion-utils';\nimport { addDomEvent } from '../events/add-dom-event.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\n\nclass FocusGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\n        }\n        catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n    }\n    unmount() { }\n}\n\nexport { FocusGesture };\n","import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\n\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nexport { layout };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX, root }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = useContext(MotionConfigContext);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        if (nonce)\n            style.nonce = nonce;\n        const parent = root ?? document.head;\n        parent.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style);\n            }\n        };\n    }, [isPresent]);\n    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) }));\n}\n\nexport { PopChild };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    let isReusedContext = true;\n    let context = useMemo(() => {\n        isReusedContext = false;\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId) => {\n                presenceChildren.set(childId, true);\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n                onExitComplete && onExitComplete();\n            },\n            register: (childId) => {\n                presenceChildren.set(childId, false);\n                return () => presenceChildren.delete(childId);\n            },\n        };\n    }, [isPresent, presenceChildren, onExitComplete]);\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context };\n    }\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { Children, isValidElement } from 'react';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\nexport { getChildKey, onlyElements };\n","\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", root }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, root: root, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst PresenceContext = \n/* @__PURE__ */ createContext(null);\n\nexport { PresenceContext };\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an HTML element in a way\n * that works across iframes\n */\nfunction isHTMLElement(element) {\n    return isObject(element) && \"offsetHeight\" in element;\n}\n\nexport { isHTMLElement };\n","const isBrowser = typeof window !== \"undefined\";\n\nexport { isBrowser };\n","import { useContext, useId, useEffect, useCallback } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = useId();\n    useEffect(() => {\n        if (subscribe) {\n            return register(id);\n        }\n    }, [subscribe]);\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\nexport { isPresent, useIsPresent, usePresence };\n","import { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nexport { useConstant };\n"],"names":["MotionConfigContext","createContext","transformPagePoint","p","isStatic","reducedMotion","defaultDatasetIdKey","reforwardRef","ref","value","current","setLabels","currentData","nextLabels","labels","setDatasets","nextDatasets","datasetIdKey","arguments","length","addedDatasets","datasets","map","nextDataset","currentDataset","find","dataset","data","includes","push","Object","assign","cloneData","nextData","ChartComponent","props","height","width","redraw","type","options","plugins","fallbackContent","updateMode","canvasProps","canvasRef","useRef","chartRef","renderChart","Chart$1","destroyChart","destroy","useEffect","chart","nextOptions","setOptions","config","setTimeout","update","React","role","Chart","forwardRef","createTypedChart","registerables","register","Line","LineController","Bar","BarController","Radar","RadarController","Doughnut","DoughnutController","PolarArea","PolarAreaController","Bubble","BubbleController","Pie","PieController","Scatter","ScatterController","LayoutGroupContext","useIsomorphicLayoutEffect","isBrowser","useLayoutEffect","round","v","lim","l","h","Math","max","min","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","a","b","c","d","e","f","hex","h1","h2","eq","hexString","r","g","isShort","alpha","undefined","HUE_RE","hsl2rgbn","s","n","k","hsv2rgbn","hwb2rgbn","w","rgb","i","rgb2hsl","hueValue","calln","Array","isArray","hsl2rgb","hue","hueParse","str","m","exec","p1","p2","hwb2rgb","hsv2rgb","x","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","nameParse","unpacked","keys","tkeys","j","ok","nk","replace","parseInt","unpack","transparent","toLowerCase","RGB_RE","to","pow","from","modHSL","ratio","tmp","clone","proto","fromObject","input","functionParse","charAt","rgbParse","Color","constructor","ret","len","hexParse","this","_rgb","_valid","valid","obj","rgbString","hslString","mix","color","weight","c1","c2","w2","w1","interpolate","t","rgb1","rgb2","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","noop","uid","id","isNullOrUndef","prototype","toString","call","slice","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toDimension","dimension","endsWith","parseFloat","callback","fn","args","thisArg","apply","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","index","source","target","create","klen","isValidKey","key","indexOf","_merger","tval","sval","merge","sources","merger","mergeIf","_mergerIf","hasOwnProperty","keyResolvers","o","y","resolveObjectKey","resolver","parts","split","part","_splitKey","_getKeyResolver","_capitalize","toUpperCase","defined","isFunction","setsEqual","size","item","has","PI","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","range","roundedRange","niceRange","floor","fraction","isNumber","Symbol","toPrimitive","isNonPrimitive","isNaN","_setMinAndMaxByKey","array","property","toRadians","degrees","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","sqrt","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_isBetween","_lookup","table","cmp","mid","hi","lo","_lookupByKey","last","ti","_rlookupByKey","arrayEvents","unlistenArrayEvents","listener","stub","_chartjs","listeners","splice","forEach","_arrayUnique","items","set","Set","requestAnimFrame","window","requestAnimationFrame","throttled","argsToUse","ticking","_len2","_key2","_toLeftRightCenter","align","_alignStartEnd","_getStartAndCountOfVisiblePoints","meta","points","animationsDisabled","pointCount","count","_sorted","iScale","vScale","_parsed","spanGaps","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","distanceToDefinedLo","findIndex","point","distanceToDefinedHi","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","atEdge","elasticIn","sin","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","numbers","colors","intlCache","Map","formatNumber","num","locale","cacheKey","JSON","stringify","formatter","get","Intl","NumberFormat","getNumberFormat","format","formatters","values","numeric","tickValue","ticks","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","Ticks","overrides","descriptors","getScope$1","node","root","scope","Defaults","_descriptors","_appliers","animation","backgroundColor","borderColor","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","enumerable","local","appliers","defaults","_scriptable","startsWith","_indexable","_fallback","delay","duration","easing","loop","properties","active","resize","show","animations","visible","hide","autoPadding","padding","top","right","bottom","left","display","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","_measureText","gc","longest","string","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","resetTransform","clearRect","drawPoint","drawPointLegend","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","_isPointInArea","area","margin","clipArea","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","decorateText","line","opts","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","strokeStyle","fillStyle","decorationWidth","drawBackdrop","oldColor","fillRect","renderText","lines","strokeWidth","strokeColor","translation","textAlign","textBaseline","setRenderOpts","backdrop","strokeText","maxWidth","fillText","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","match","numberOrZero","_readValueToProps","objProps","read","prop","toTRBL","toTRBLCorners","toPadding","toFont","fallback","console","warn","toFontString","resolve","inputs","info","cacheable","parentContext","_createResolver","scopes","prefixes","getTarget","finalRootScopes","_resolve","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","isScriptable","getValue","Error","join","add","delete","_resolveScriptable","isIndexable","arr","filter","_resolveArray","_resolveWithContext","allKeys","configurable","scriptable","indexable","_allKeys","resolveFallback","getScope","parent","addScopes","parentScopes","parentFallback","rootScopes","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","parsed","parse","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","next","d01","d12","s01","s12","fa","fb","splineCurveMonotone","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","pt","_updateBezierControlPoints","controlPoints","cubicInterpolationMode","prev","tension","capBezierPoints","inArea","inAreaPrev","inAreaNext","_isDomSupported","document","_getParentNode","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","ownerDocument","defaultView","positions","getPositionedStyle","styles","suffix","result","pos","getRelativePosition","event","borderBox","boxSizing","paddings","borders","box","touches","offsetX","offsetY","useOffsetPos","shadowRoot","getBoundingClientRect","clientX","clientY","getCanvasPosition","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","maxHeight","containerSize","container","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","getContainerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","el","getPropertyValue","getStyle","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","getRtlAdapter","rtl","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","_ref","_boundSegment","segment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","_boundSegments","segments","sub","splitByStyles","segmentOptions","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","doSplitByStyles","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","replacer","getSizeForArea","chartArea","field","getDatasetClipArea","_clip","disabled","getDatasetArea","Animator","_request","_charts","_running","_lastDate","_notify","anims","date","callbacks","numSteps","initial","currentStep","_refresh","_update","Date","now","remaining","running","draw","_active","_total","tick","pop","_getAnims","charts","complete","progress","listen","cb","reduce","acc","cur","_duration","stop","cancel","remove","animator","interpolators","boolean","factor","c0","number","Animation","cfg","currentValue","_fn","_easing","_start","_loop","_target","_prop","_from","_to","_promises","elapsed","wait","promises","Promise","res","rej","resolved","method","Animations","_properties","configure","animationOptions","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","$shared","$animations","resolveTargetOptions","_createAnimations","anim","all","awaitAll","then","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","applyStack","stack","dsIndex","singleMode","otherValue","found","isStacked","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","positive","getMatchingVisibleMetas","updateStacks","controller","_cachedMeta","_stacks","iAxis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","_visualValues","getFirstScaleId","shift","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","static","_cachedDataOpts","getMeta","_type","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","getScaleForId","rScale","getDatasetMeta","scaleID","_getOtherScale","reset","_destroy","_dataCheck","iAxisKey","vAxisKey","adata","convertObjectDataToArray","isExtensible","defineProperty","base","_len","_key","object","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","parsedValue","NaN","getMinMax","canStack","otherScale","createStack","hidden","NEGATIVE_INFINITY","otherMin","otherMax","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","toClip","defaultClip","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","transition","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","computeMinSampleSize","_cache","$bar","visibleMetas","concat","sort","getAllScaleValues","curr","_length","updateMinAndPrev","getPixelForTick","parseValue","entry","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","edge","borderSkipped","horizontal","borderProps","enableBorderRadius","parseEdge","orig","v2","startEnd","setInflateAmount","inflateAmount","categoryPercentage","barPercentage","grouped","_index_","_value_","super","bars","getBasePixel","isHorizontal","ruler","_getRuler","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","center","_getStacks","currentParsed","iScaleValue","skipNull","_getStackCount","_getAxisCount","_getAxis","getFirstScaleIdForIndexAxis","indexScaleId","firstScaleAxisId","_getStackIndex","pixels","barThickness","_startPixel","_endPixel","stackCount","baseValue","minBarLength","actualBase","floating","getDataVisibility","barSign","startPixel","getPixelForDecimal","endPixel","getValueForPixel","halfGrid","getLineWidthForValue","maxBarThickness","Infinity","axisCount","percent","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","axisID","axisNumber","stackIndex","rects","animateRotate","animateScale","cutout","circumference","spacing","legend","generateLabels","fontColor","legendItem","toggleDataVisibility","innerRadius","outerRadius","getter","_getRotation","_getCircumference","_getRotationExtents","isDatasetVisible","arcs","getMaxBorderWidth","getMaxOffset","maxSize","toPercentage","chartWeight","_getRingWeight","ratioX","ratioY","startAngle","endAngle","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","animationOpts","centerX","centerY","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","_dataset","_decimated","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","updateControlPoints","angleLines","circular","pointLabels","bind","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","_fullLoop","pointPosition","getPointPositionForValue","registry","getElement","abstract","DateAdapterBase","members","init","formats","diff","startOf","endOf","adapters","binarySearch","metaset","lookupMethod","_reversePixels","getRange","evaluateInteractionItems","position","handler","getSortedVisibleDatasetMetas","getIntersectItems","useFinalPosition","isPointInArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getCenterPoint","getNearestItems","getProps","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","layouts","params","wrap","stackWeight","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","other","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","addBox","_layers","z","removeBox","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","updatePos","change","handleMaxPadding","BasePlatform","acquireContext","releaseContext","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","entries","trigger","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","native","fromNativeEvent","addListener","DomPlatform","renderHeight","getAttribute","renderWidth","displayWidth","displayHeight","initCanvas","removeAttribute","setAttribute","proxies","$proxies","attach","detach","isConnected","Element","tooltipPosition","hasValue","final","tickOpts","determinedMaxTicks","_tickSize","maxScale","maxChart","_maxLength","determineMaxTicks","ticksLimit","maxTicksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","first","newTicks","ceil","skipMajors","evenMajorSpacing","getEvenSpacing","factors","_factorize","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","titleAlign","reverseAlign","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","minmax","keepZero","_addGrace","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","idx","decimal","getDecimalForPixel","getBaseValue","createTickContext","optionTicks","rot","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","titleX","titleY","titleArgs","tz","gz","bz","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","parentScope","isIChartComponent","itemDefaults","defaultRoutes","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","unregister","Registry","controllers","_typedRegistries","_each","addControllers","_len3","_key3","_len4","_key4","addPlugins","_len5","_key5","addScales","_len6","_key6","getController","_get","getPlugin","getScale","removeControllers","_len7","_key7","removeElements","_len8","_key8","removePlugins","_len9","_key9","removeScales","_len0","_key0","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","component","camelMethod","PluginService","_init","notify","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","allPlugins","_ref2","getOpts","pluginOpts","createDescriptors","previousDescriptors","some","_ref3","pluginScopeKeys","getIndexAxis","datasetDefaults","idMatchesAxis","axisFromPosition","determineAxis","_len1","scaleOptions","_key1","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","invalidatePlugins","userConfig","initialCanvas","existingChart","OffscreenCanvas","_detectPlatform","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","timeout","clearTimeout","debounce","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","buildOrUpdateControllers","newControllers","order","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","_ref4","pluginId","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","_isClickEvent","lastEvent","determineLastEvent","parseBorderRadius$1","angleDelta","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","pixelMargin","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","fullCircles","inner","lineJoin","angleMargin","clipArc","selfJoin","outerAngleClip","innerAngleClip","clipWidth","clipSelf","ArcElement","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","setStyle","lineCap","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","path","_path","strokePathWithCache","segmentMethod","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","findStartAndEnd","solidSegments","_computeSegments","_interpolate","_getInterpolationMethod","interpolated","inRange$1","hitRadius","PointElement","hoverRadius","mouseX","mouseY","inXRange","inYRange","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","BarElement","addRectPath","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_ref5","_pointsFromSegments","_shouldApplyFill","_resolveTarget","propagate","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","unshift","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","below","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","above","fillColor","clipVertical","clipHorizontal","doFill","clipY","lineLoop","clipX","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","_args","$filler","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","adjustHitBoxes","rtlHelper","hitbox","_draw","defaultColor","halfFontSize","cursor","textDirection","lineDash","drawOptions","SQRT2","yBoxTop","xBoxLeft","drawLegendBox","_textX","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","sameItem","itemsEqual","plugin_legend","_element","afterEvent","ci","useBorderRadius","Title","_padding","textSize","_drawArgs","fontOpts","plugin_title","titleBlock","createTitle","WeakMap","positioners","average","xSet","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","createTooltipItem","formattedValue","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","beforeTitle","tooltipItems","labelCount","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","_ref6","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","findOrAddLabel","addedLabels","addIfString","lastIndexOf","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","generateTicks$1","generationOptions","dataRange","precision","maxTicks","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","minSpacing","niceMin","niceMax","numSpaces","rounded","almostWhole","decimalPlaces","relativeLabelSize","_ref7","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","stepSize","computeTickLimit","LinearScale","getTickBackdropHeight","measureLabelSize","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","updateLimits","setCenterPoint","_pointLabelItems","itemOpts","extra","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","RadialLinearScale","animate","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","gridLineOpts","drawRadiusLine","INTERVALS","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","time","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","displayFormats","_unit","_majorUnit","_offsets","_normalized","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_filterBetween","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","transformPropOrder","transformProps","radToDeg","rebaseAngle","matrix2dParsers","translateX","translateY","scaleX","scaleY","rotateZ","skewX","atan","skewY","skew","matrix3dParsers","translateZ","rotateX","rotateY","defaultTransformValue","parseValueFromTransform","transform","matrix3dMatch","parsers","matrix2dMatch","valueParser","convertTransformToNumber","trim","checkStringStartsWith","token","isCSSVariableName","startsAsVariableToken","isCSSVariableToken","singleCssVariableRegex","test","convertBoundingBoxToBox","mixNumber","isIdentityScale","hasScale","hasTransform","has2DTranslate","is2DTranslate","scalePoint","originPoint","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","translateAxis","transformAxis","axisTranslate","axisScale","axisOrigin","transformBox","originX","originY","measureViewportBox","instance","transformPoint","transformBoxPoints","positionalKeys","clamp","default","createUnitType","px","vh","vw","progressPercentage","testValueType","dimensionValueTypes","findDimensionValueType","isNumericalString","splitCSSVariableRegex","getVariableValue","depth","token1","token2","parseCSSVariable","trimmed","isNumOrPxType","transformKeys","nonTranslationalTransformKeys","positionalValues","_bbox","_ref8","_ref9","_ref0","_ref1","_ref10","any","MotionGlobalConfig","stepsOrder","statsBuffer","addProjectionMetrics","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","timestamp","isProcessing","flagRunNextFrame","stepName","thisFrame","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","numCalls","triggerCallback","schedule","queue","process","frameData","frameloop","createRenderStep","setup","resolveKeyframes","preUpdate","preRender","postRender","processBatch","useManualTiming","performance","keepAlive","immediate","frame","cancelFrame","frameSteps","toResolve","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","needsMeasurement","elementsToMeasure","transformsToRestore","removedTransforms","visualElement","removeNonTranslationalTransform","measureInitialState","measureEndState","suspendedScrollY","scrollTo","readAllKeyframes","readKeyframes","KeyframeResolver","unresolvedKeyframes","motionValue","isAsync","scheduleResolve","finalKeyframe","valueAsRead","readValue","keyframes","fillWildcards","setFinalKeyframe","renderEndStyles","isForcedComplete","resume","isZeroValueString","isNone","sanitize","floatRegex","singleColorRegex","isColorString","testProp","Boolean","isNullish","splitColor","aName","bName","cName","rgbUnit","clampRgbUnit","rgba","red","green","blue","alpha$1","substring","hsla","saturation","lightness","getAnimatableNone","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","complexRegex","analyseComplexValue","originalValue","indexes","var","types","parseComplexValue","createTransformer","numSections","output","convertNumbersToZero","complex","transformer","maxDefaults","applyDefaultFilter","functionRegex","functions","int","numberValueTypes","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","marginTop","marginRight","marginBottom","marginLeft","backgroundPositionX","backgroundPositionY","scaleZ","perspective","transformPerspective","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","defaultValueTypes","outlineColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","defaultValueType","invalidTemplates","DOMKeyframesResolver","keyframe","resolveNoneKeyframes","origin","originType","targetType","noneKeyframeIndexes","animatableTemplate","noneIndex","makeNoneKeyframesAnimatable","pageYOffset","measuredOrigin","measureKeyframe","jump","finalKeyframeIndex","unsetTransformName","unsetTransformValue","isMotionValue","getVelocity","clearTime","newTime","queueMicrotask","addUniqueItem","removeItem","SubscriptionManager","subscriptions","numSubscriptions","getSize","velocityPerSecond","velocity","frameDuration","collectMotionValues","MotionValue","canTrackVelocity","updateAndNotify","currentTime","updatedAt","setPrevFrameValue","setCurrent","dependents","dependent","dirty","hasAnimated","owner","prevFrameValue","prevUpdatedAt","onChange","subscription","on","eventName","unsubscribe","clearListeners","eventManagers","passiveEffect","stopPassiveEffect","setWithVelocity","endAnimation","addDependent","removeDependent","getPrevious","startAnimation","animationStart","animationComplete","clearAnimation","animationCancel","isAnimating","valueTypes","microtask","cancelMicrotask","featureProps","exit","drag","focus","tap","pan","inView","featureDefinitions","isEnabled","createBox","prefersReducedMotion","hasReducedMotionListener","visualElementStore","isAnimationControls","isVariantLabel","variantPriorityOrder","variantProps","isControllingVariants","isVariantNode","variants","getValueState","resolveVariantFromProps","definition","propEventHandlers","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","presenceContext","reducedMotionConfig","blockInitialAnimation","visualState","children","shouldReduceMotion","features","valueSubscriptions","prevMotionValues","propEventSubscriptions","notifyUpdate","latestValues","triggerBuild","renderInstance","renderState","projection","renderScheduledAt","scheduleRender","baseTarget","initialValues","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","mount","removeFromVariantTree","addVariantChild","bindToMotionValue","matchMedia","motionMediaQuery","setReducedMotionPreferences","initPrefersReducedMotion","addChild","unmount","removeChild","feature","isMounted","child","enteringChildren","valueIsTransform","onBindTransform","removeOnChange","latestValue","onUpdate","isTransformDirty","removeSyncCheck","MotionCheckAppearSync","sortNodePosition","sortInstanceNodePosition","updateFeatures","featureDefinition","Feature","FeatureConstructor","build","measureInstanceViewportBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","nextValue","addValue","existingValue","liveStyle","removeValue","updateMotionValuesFromProps","handleChildMotionValue","getVariant","getDefaultTransition","getTransformPagePoint","getClosestVariantNode","closestVariantNode","removeValueFromRenderState","getBaseTargetFromProps","readValueFromInstance","setBaseTarget","getBaseTarget","valueFromInitial","variant","scheduleRenderMicrotask","DOMVisualElement","compareDocumentPosition","vars","childSubscription","latest","textContent","getValueAsType","translateAlias","numTransforms","buildHTMLStyles","transformOrigin","hasTransformOrigin","valueAsType","transformString","transformIsDefault","valueIsDefault","buildTransform","renderHTML","styleProp","elementStyle","applyProjectionStyles","scaleCorrectors","isForcedMotionValue","layoutId","newValues","HTMLVisualElement","isProjecting","readTransformValue","computedStyle","camelToDash","dashKeys","camelKeys","buildSVGAttrs","isSVGTag","attrX","attrY","attrScale","pathLength","pathSpacing","pathOffset","viewBox","attrs","useDashCase","buildSVGPath","camelCaseAttributes","tag","scrapeMotionValuesFromProps$1","SVGVisualElement","defaultType","_styleProp","renderSVG","tagName","lowercaseSVGElements","isSVGComponent","Component","createDomVisualElement","allowProjection","Fragment","LazyContext","strict","MotionContext","useCreateMotionContext","inherit","getCurrentTreeVariants","useContext","useMemo","variantLabelsAsDependency","createHtmlRenderState","copyRawValuesOnly","useStyle","useInitialMotionValues","useHTMLProps","htmlProps","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","tabIndex","onTap","onTapStart","whileTap","createSvgRenderState","useSVGProps","_isStatic","visualProps","rawStyles","validMotionProps","isValidMotionProp","shouldForward","isValidProp","require","useRender","forwardMotionProps","filteredProps","isDom","filterProps","elementProps","renderedChildren","createElement","resolveMotionValue","makeLatestValues","scrapeMotionValues","motionValues","isControllingVariants$1","isVariantNode$1","isInitialAnimationBlocked","variantToSet","list","transitionEnd","valueTarget","makeUseVisualState","PresenceContext","make","createRenderState","makeState","useConstant","useHTMLVisualState","useSVGVisualState","motionComponentSymbol","for","isRefObject","useMotionRef","externalRef","useCallback","onMount","optimizedAppearDataAttribute","SwitchLayoutGroupContext","useVisualElement","createVisualElement","ProjectionNodeConstructor","lazyContext","visualElementRef","renderer","initialLayoutGroupConfig","initialPromotionConfig","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","getClosestProjectingNode","alwaysMeasureLayout","animationType","crossfade","createProjectionNode","useInsertionEffect","optimisedAppearId","wantsHandoff","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","animationState","animateChanges","MotionHandoffMarkAsComplete","createMotionComponent","preloadedFeatures","loadFeatures","useVisualState","MotionDOMComponent","MeasureLayout","configAndProps","useLayoutId","useStrictMode","layoutProjection","combined","ProjectionNode","getProjectionFunctionality","jsxs","Provider","jsx","displayName","ForwardRefMotionComponent","layoutGroupId","createMotionProxy","componentCache","factory","deprecatedFactoryFunction","resolveVariant","getValueTransition","isKeyframesTarget","setMotionValue","resolveFinalValueInKeyframes","addValueToWillChange","WillChange","newWillChange","getOptimisedAppearId","makeAnimationInstant","combineFunctions","pipe","transformers","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","activeAnimations","mainThread","waapi","hueToRgb","q","mixImmediate","mixLinearColor","fromExpo","expo","colorTypes","asRGBA","model","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","invisibleValues","mixNumber$1","getMixer","mixComplex","mixArray","mixObject","numValues","blendValue","template","originStats","targetStats","mixVisibility","orderedOrigin","pointers","originIndex","originValue","matchOrder","mixer","frameloopDriver","passTimestamp","generateLinearEasing","resolution","numPoints","maxGeneratorDuration","calcGeneratorDuration","generator","done","calcGeneratorVelocity","resolveValue","prevT","springDefaults","stiffness","damping","mass","bounce","visualDuration","restSpeed","granular","restDelta","minDuration","maxDuration","minDamping","maxDamping","safeMin","findSpring","envelope","derivative","dampingRatio","undampedFreq","exponentialDecay","calcAngularFreq","exp","initialGuess","rootIterations","approximateRoot","durationKeys","physicsKeys","isSpringType","spring","optionsOrVisualDuration","isResolvedFromDuration","springOptions","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","resolveSpring","angularFreq","dampedAngularFreq","freqForT","sinh","cosh","calculatedDuration","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toTransition","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","amplitude","ideal","calcDelta","calcLatest","applyFriction","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","applyToOptions","generatorOptions","ease","createGeneratorEasing","calcBezier","a2","cubicBezier","mX1","mY1","mX2","mY2","getTForX","aX","lowerBound","upperBound","currentX","currentT","binarySubdivide","easeIn","easeOut","easeInOut","mirrorEasing","reverseEasing","backOut","backIn","backInOut","anticipate","circIn","acos","circOut","circInOut","isBezierDefinition","easingLookup","easingDefinitionToFunction","toFromDifference","isClamp","inputLength","isZeroDeltaRange","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","defaultOffset","offsetProgress","fillOffset","keyframeValues","times","easingFunctions","isEasingArray","absoluteTimes","convertOffsetToTimes","mapTimeToKeyframe","isNotNull","getFinalKeyframe","repeat","repeatType","speed","resolvedKeyframes","transitionTypeMap","decay","tween","replaceTransitionType","WithPromise","updateFinished","finished","_finished","notifyFinished","onResolve","onReject","percentToProgress","JSAnimation","startTime","isStopped","holdTime","playbackSpeed","teardown","onStop","initAnimation","play","autoplay","pause","repeatDelay","keyframes$1","generatorFactory","mixKeyframes","mirroredGenerator","resolvedDuration","totalDuration","updateTime","animationTime","timeWithoutDelay","isInDelayPhase","frameGenerator","currentIteration","iterationProgress","isAnimationFinished","finish","reject","driver","newSpeed","hasChanged","onPlay","onCancel","stopDriver","sampleTime","attachTimeline","timeline","allowFlatten","memo","supportsScrollTimeline","ScrollTimeline","supportsFlags","memoSupports","supportsFlag","memoized","supportsLinearEasing","cubicBezierAsString","supportedWaapiEasing","mapEasingToNativeEasing","segmentEasing","startWaapiAnimation","valueName","pseudoElement","keyframeOptions","iterations","finally","isGenerator","NativeAnimation","finishedTime","isPseudoElement","applyGeneratorOptions","onfinish","updateMotionValue","isCSSVar","commitStyles","effect","getComputedTiming","playbackRate","playState","newStartTime","updateTiming","unsupportedEasingFunctions","replaceStringEasing","NativeAnimationExtended","sampleAnimation","isAnimatable","acceleratedValues","supportsWaapi","AsyncMotionValueAnimation","_animation","stopTimeline","keyframeResolver","createdAt","optionsWithDefaults","KeyframeResolver$1","forced","onKeyframesResolved","sync","isHandoff","resolvedAt","originKeyframe","targetKeyframe","isOriginAnimatable","isTargetAnimatable","hasKeyframesChanged","canAnimate","instantAnimations","resolvedOptions","subject","HTMLElement","supportsBrowserAnimation","catch","pendingTimeline","_onReject","underDampedSpring","keyframesTransition","valueKey","animateMotionValue","valueTransition","when","_delay","delayChildren","staggerChildren","staggerDirection","isTransitionDefined","shouldSkip","skipAnimations","isSync","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","targetAndTransition","transitionOverride","animationTypeState","getState","MotionHandoffAnimation","appearId","setTarget","calcChildStagger","numChildren","maxStaggerDuration","animateVariant","getAnimation","getChildAnimations","forwardDelay","animateChildren","shallowCompare","prevLength","numVariantProps","getVariantContext","reversePriorityOrder","numAnimationTypes","animateList","resolvedDefinition","animateVisualElement","createAnimationState","createState","isInitialRender","buildResolvedTypeValues","changedActiveType","removedKeys","encounteredKeys","removedVariantIndex","typeState","propIsVariant","activeDelta","isActive","isInherited","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","resolvedValues","prevResolvedValues","markToAnimate","valueHasChanged","willAnimateViaParent","parentVariant","fallbackAnimation","initialTransition","fallbackTarget","shouldAnimate","setActive","setAnimateFunction","makeAnimator","createTypeState","whileInView","whileHover","whileDrag","whileFocus","updateAnimationControlsSubscription","unmountControls","subscribe","prevAnimate","isPresent","onExitComplete","prevIsPresent","exitAnimation","isDragging","isDragActive","addDomEvent","isPrimaryPointer","pointerType","button","isPrimary","extractEventInfo","pageX","pageY","addPointerEvent","addPointerInfo","calcLength","calcAxisDelta","calcBoxDelta","calcRelativeAxis","relative","calcRelativeAxisPosition","calcRelativePosition","eachAxis","getContextWindow","PanSession","handlers","contextWindow","dragSnapToOrigin","distanceThreshold","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","getPanInfo","history","isPanStarted","isDistancePastThreshold","xDelta","yDelta","distance2D","onStart","onMove","handlePointerMove","handlePointerUp","onEnd","onSessionEnd","resumeAnimation","panInfo","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","lastDevicePoint","startDevicePoint","timeDelta","timestampedPoint","calcRelativeAxisConstraints","calcViewportAxisConstraints","layoutAxis","constraintsAxis","defaultElastic","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","elementDragControls","VisualElementDragControls","openDragLock","currentDirection","constraints","hasMutatedConstraints","elastic","latestPointerEvent","latestPanInfo","originEvent","snapToCursor","panSession","pauseAnimation","stopAnimation","dragPropagation","onDragStart","resolveConstraints","isAnimationBlocked","getAxisMotionValue","measuredAxis","layoutBox","dragDirectionLock","onDirectionLock","onDrag","lockThreshold","getCurrentDirection","updateAxis","getAnimationState","finalEvent","finalPanInfo","onDragEnd","_point","shouldDrag","axisValue","applyConstraints","measure","prevConstraints","resolveRefConstraints","calcRelativeConstraints","resolveDragElastic","relativeConstraints","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","rootProjectionNode","viewportBox","scroll","measurePageBox","measuredConstraints","calcViewportConstraints","userConstraints","convertBoxToBoundingBox","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","startAxisValueAnimation","dragKey","externalMotionValue","scalePositionWithinConstraints","boxProgress","sourceLength","targetLength","calcOrigin","updateScroll","updateLayout","addListeners","stopPointerListener","measureDragConstraints","stopMeasureLayoutListener","stopResizeListener","stopLayoutUpdateListener","hasLayoutChanged","asyncHandler","globalProjectionState","hasAnimatedSinceResize","hasEverUpdated","pixelsToPercent","correctBorderRadius","correct","correctBoxShadow","treeScale","projectionDelta","shadow","averageScale","hasTakenAnySnapshot","MeasureLayoutWithContext","componentDidMount","layoutGroup","switchLayoutGroup","correctors","isCSSVariable","addScaleCorrector","defaultScaleCorrectors","group","didUpdate","safeToRemove","getSnapshotBeforeUpdate","layoutDependency","willUpdate","promote","relegate","getStack","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","deregister","usePresence","applyTo","boxShadow","isSVGElement","compareByDepth","FlatTree","isDirty","checkElapsed","numBorders","asNumber","isPx","getRadius","radiusName","easeCrossfadeIn","compress","easeCrossfadeOut","copyAxisInto","originAxis","copyBoxInto","originBox","copyAxisDeltaInto","originDelta","removePointDelta","removeAxisTransforms","transforms","sourceAxis","scaleKey","originKey","removeAxisDelta","xKeys","yKeys","removeBoxTransforms","sourceBox","isAxisDeltaZero","isDeltaZero","axisEquals","axisEqualsRounded","boxEqualsRounded","axisDeltaEquals","NodeStack","prevLead","lead","indexOfNode","member","preserveFollowOpacity","resumeFrom","preserveOpacity","snapshot","animationValues","isUpdating","isLayoutDirty","exitAnimationComplete","resumingFrom","removeLeadSnapshot","nodes","calculatedTargetDeltas","calculatedProjections","transformAxes","resetDistortingTransform","sharedAnimationValues","cancelTreeOptimisedTransformAnimations","projectionNode","hasCheckedOptimisedAppear","MotionCancelOptimisedAnimation","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","animationId","animationCommitId","isTreeAnimating","isProjectionDirty","isSharedProjectionDirty","updateManuallyBlocked","updateBlockedByResize","isSVG","needsReset","shouldResetTransform","eventHandlers","hasTreeAnimated","updateScheduled","scheduleUpdate","projectionUpdateScheduled","checkUpdateFailed","clearAllSnapshots","updateProjection","propagateDirtyNodes","resolveTargetDelta","calcProjection","cleanDirtyNodes","resolvedRelativeTargetAt","hasProjected","isVisible","animationProgress","sharedNodes","notifyListeners","subscriptionManager","hasListeners","cancelDelay","innerWidth","resizeUnblockUpdate","newInnerWidth","finishAnimation","registerSharedNode","hasRelativeLayoutChanged","newLayout","isTreeAnimationBlocked","relativeTarget","layoutTransition","defaultLayoutTransition","onLayoutAnimationStart","onLayoutAnimationComplete","hasTargetChanged","targetLayout","hasOnlyRelativeTargetChanged","setAnimationOrigin","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","resetSkewAndRotation","getTransformTemplate","shouldNotifyListeners","prevTransformTemplateValue","updateSnapshot","clearMeasurements","clearIsLayoutDirty","resetTransformStyle","notifyLayoutUpdate","clearSnapshot","removeLeadSnapshots","scheduleUpdateProjection","measuredBox","prevLayout","layoutCorrected","phase","isRoot","wasRoot","isResetRequested","hasProjection","transformTemplateValue","transformTemplateHasChanged","removeTransform","pageBox","removeElementScroll","roundAxis","checkNodeWasScrollRoot","boxWithoutScroll","applyTransform","transformOnly","withTransforms","boxWithoutTransform","setTargetDelta","targetDelta","forceRelativeParentToResolveTarget","relativeParent","forceRecalculation","getLead","isShared","attemptToResolveRelativeTarget","getClosestProjectingParent","relativeTargetOrigin","targetWithTransforms","canSkip","pendingAnimation","prevTreeScaleX","prevTreeScaleY","treePath","isSharedTransition","treeLength","applyTreeDeltas","prevProjectionDelta","createProjectionDeltas","notifyAll","projectionDeltaWithTransform","snapshotLatestValues","mixedValues","relativeLayout","isSharedLayoutAnimation","isOnlyMember","shouldCrossfadeOpacity","hasOpacityCrossfade","prevRelativeTarget","mixTargetDelta","mixAxisDelta","mixAxis","follow","opacityExit","borderLabel","followRadius","leadRadius","mixValues","motionValue$1","animateSingleValue","completeAnimation","applyTransformsToTarget","shouldAnimatePositionOnly","xLength","yLength","shouldPreserveFollowOpacity","getPrevLead","hasDistortingTransform","resetValues","targetStyle","visibility","pointerEvents","valuesToRender","latestTransform","xTranslate","yTranslate","zTranslate","elementScaleX","elementScaleY","buildProjectionTransform","corrected","resetTree","measuredLayout","axisSnapshot","layoutDelta","visualDelta","parentSnapshot","parentLayout","relativeSnapshot","onBeforeLayoutMeasure","userAgentContains","navigator","userAgent","roundPoint","maxDistance","DocumentProjectionNode","documentElement","scrollLeft","scrollTop","HTMLProjectionNode","documentNode","removePointerDownListener","onPointerDown","pointerDownEvent","session","createPanHandlers","onPanSessionStart","onPanStart","onPan","onPanEnd","removeGroupControls","controls","dragControls","setupGesture","elementOrSelector","selectorCache","EventTarget","querySelectorAll","resolveElements","gestureAbortController","AbortController","signal","abort","isValidHover","handleHoverEvent","lifecycle","isNodeOrChild","parentElement","focusableElements","isPressing","filterEvents","firePointerEvent","dispatchEvent","PointerEvent","bubbles","isValidPressEvent","press","targetOrSelector","onPressStart","targets","eventOptions","cancelEvents","startPress","currentTarget","onPressEnd","onPointerEnd","endEvent","success","onPointerUp","onPointerCancel","upEvent","useGlobalTarget","cancelEvent","isHTMLElement","enableKeyboardPress","focusEvent","handleKeydown","handleKeyup","handleBlur","hasAttribute","handlePressEvent","HTMLButtonElement","observerCallbacks","observers","fireObserverCallback","fireAllObserverCallbacks","observeIntersection","rootInteresectionObserver","lookupRoot","rootObservers","IntersectionObserver","initIntersectionObserver","unobserve","thresholdNames","motion","hasEnteredView","isInView","startObserver","viewport","rootMargin","once","threshold","isIntersecting","onViewportEnter","onViewportLeave","hasOptionsChanged","prevViewport","hasViewportOptionChanged","globalTapTarget","onFocus","isFocusVisible","onBlur","onHoverStart","onPointerEnter","enterEvent","onHoverEnd","onPointerLeave","leaveEvent","PopChildMeasure","childRef","offsetParent","parentWidth","offsetWidth","sizeRef","offsetHeight","offsetTop","PopChild","anchorX","useId","nonce","motionPopId","appendChild","sheet","insertRule","PresenceChild","presenceAffectsLayout","presenceChildren","newChildrenMap","isReusedContext","childId","isComplete","_","getChildKey","onlyElements","filtered","Children","isValidElement","AnimatePresence","isParentPresent","presentChildren","presentKeys","pendingPresentChildren","exitComplete","diffedChildren","setDiffedChildren","useState","setRenderedChildren","exitingChildren","nextChildren","forceRender","onExit","isEveryExitComplete","isExitComplete"],"sourceRoot":""}