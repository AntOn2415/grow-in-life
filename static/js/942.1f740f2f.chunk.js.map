{"version":3,"file":"static/js/942.1f740f2f.chunk.js","mappings":"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","sources":["../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../node_modules/framer-motion/dist/es/utils/is-browser.mjs","../node_modules/framer-motion/dist/es/utils/use-constant.mjs","../node_modules/react-chartjs-2/src/utils.ts","../node_modules/react-chartjs-2/src/chart.tsx","../node_modules/react-chartjs-2/src/typedCharts.tsx","../node_modules/motion-dom/dist/es/render/utils/keys-transform.mjs","../node_modules/motion-dom/dist/es/render/dom/parse-transform.mjs","../node_modules/motion-dom/dist/es/animation/utils/is-css-variable.mjs","../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs","../node_modules/motion-dom/dist/es/utils/mix/number.mjs","../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs","../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","../node_modules/framer-motion/dist/es/projection/utils/measure.mjs","../node_modules/motion-dom/dist/es/render/utils/keys-position.mjs","../node_modules/motion-utils/dist/es/clamp.mjs","../node_modules/motion-dom/dist/es/value/types/numbers/index.mjs","../node_modules/motion-dom/dist/es/value/types/numbers/units.mjs","../node_modules/motion-dom/dist/es/value/types/test.mjs","../node_modules/motion-dom/dist/es/value/types/dimensions.mjs","../node_modules/motion-dom/dist/es/value/types/auto.mjs","../node_modules/motion-utils/dist/es/is-numerical-string.mjs","../node_modules/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs","../node_modules/motion-utils/dist/es/noop.mjs","../node_modules/motion-utils/dist/es/global-config.mjs","../node_modules/motion-dom/dist/es/frameloop/order.mjs","../node_modules/motion-dom/dist/es/stats/buffer.mjs","../node_modules/motion-dom/dist/es/frameloop/batcher.mjs","../node_modules/motion-dom/dist/es/frameloop/render-step.mjs","../node_modules/motion-dom/dist/es/frameloop/frame.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs","../node_modules/motion-utils/dist/es/is-zero-value-string.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs","../node_modules/motion-dom/dist/es/value/types/utils/sanitize.mjs","../node_modules/motion-dom/dist/es/value/types/utils/float-regex.mjs","../node_modules/motion-dom/dist/es/value/types/utils/single-color-regex.mjs","../node_modules/motion-dom/dist/es/value/types/color/utils.mjs","../node_modules/motion-dom/dist/es/value/types/utils/is-nullish.mjs","../node_modules/motion-dom/dist/es/value/types/color/rgba.mjs","../node_modules/motion-dom/dist/es/value/types/color/hex.mjs","../node_modules/motion-dom/dist/es/value/types/color/hsla.mjs","../node_modules/motion-dom/dist/es/value/types/color/index.mjs","../node_modules/motion-dom/dist/es/value/types/utils/color-regex.mjs","../node_modules/motion-dom/dist/es/value/types/complex/index.mjs","../node_modules/motion-dom/dist/es/value/types/complex/filter.mjs","../node_modules/motion-dom/dist/es/value/types/int.mjs","../node_modules/motion-dom/dist/es/value/types/maps/number.mjs","../node_modules/motion-dom/dist/es/value/types/maps/transform.mjs","../node_modules/motion-dom/dist/es/value/types/maps/defaults.mjs","../node_modules/motion-dom/dist/es/value/types/utils/animatable-none.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs","../node_modules/motion-dom/dist/es/value/utils/is-motion-value.mjs","../node_modules/motion-dom/dist/es/frameloop/sync-time.mjs","../node_modules/motion-utils/dist/es/array.mjs","../node_modules/motion-utils/dist/es/subscription-manager.mjs","../node_modules/motion-utils/dist/es/velocity-per-second.mjs","../node_modules/motion-dom/dist/es/value/index.mjs","../node_modules/motion-dom/dist/es/value/types/utils/find.mjs","../node_modules/motion-dom/dist/es/frameloop/microtask.mjs","../node_modules/framer-motion/dist/es/motion/features/definitions.mjs","../node_modules/framer-motion/dist/es/projection/geometry/models.mjs","../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs","../node_modules/framer-motion/dist/es/render/store.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs","../node_modules/framer-motion/dist/es/render/utils/variant-props.mjs","../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs","../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs","../node_modules/framer-motion/dist/es/render/VisualElement.mjs","../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs","../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs","../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs","../node_modules/motion-dom/dist/es/value/types/utils/get-as-type.mjs","../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs","../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs","../node_modules/framer-motion/dist/es/render/html/utils/render.mjs","../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs","../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs","../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs","../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs","../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs","../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs","../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs","../node_modules/framer-motion/dist/es/context/LazyContext.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs","../node_modules/framer-motion/dist/es/render/html/use-props.mjs","../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs","../node_modules/framer-motion/dist/es/render/svg/use-props.mjs","../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs","../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs","../node_modules/framer-motion/dist/es/render/dom/use-render.mjs","../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs","../node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs","../node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs","../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs","../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs","../node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","../node_modules/framer-motion/dist/es/motion/index.mjs","../node_modules/framer-motion/dist/es/motion/features/load-features.mjs","../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs","../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs","../node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","../node_modules/framer-motion/dist/es/render/utils/setters.mjs","../node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs","../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs","../node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","../node_modules/motion-dom/dist/es/animation/utils/make-animation-instant.mjs","../node_modules/motion-utils/dist/es/pipe.mjs","../node_modules/motion-utils/dist/es/time-conversion.mjs","../node_modules/motion-dom/dist/es/stats/animation-count.mjs","../node_modules/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs","../node_modules/motion-dom/dist/es/utils/mix/immediate.mjs","../node_modules/motion-dom/dist/es/utils/mix/color.mjs","../node_modules/motion-dom/dist/es/utils/mix/visibility.mjs","../node_modules/motion-dom/dist/es/utils/mix/complex.mjs","../node_modules/motion-dom/dist/es/utils/mix/index.mjs","../node_modules/motion-dom/dist/es/animation/drivers/frame.mjs","../node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/velocity.mjs","../node_modules/motion-dom/dist/es/animation/generators/spring/defaults.mjs","../node_modules/motion-dom/dist/es/animation/generators/spring/find.mjs","../node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs","../node_modules/motion-dom/dist/es/animation/generators/inertia.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs","../node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs","../node_modules/motion-utils/dist/es/easing/ease.mjs","../node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs","../node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs","../node_modules/motion-utils/dist/es/easing/back.mjs","../node_modules/motion-utils/dist/es/easing/anticipate.mjs","../node_modules/motion-utils/dist/es/easing/circ.mjs","../node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs","../node_modules/motion-utils/dist/es/easing/utils/map.mjs","../node_modules/motion-utils/dist/es/progress.mjs","../node_modules/motion-dom/dist/es/utils/interpolate.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/offsets/default.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs","../node_modules/motion-dom/dist/es/animation/generators/keyframes.mjs","../node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/offsets/time.mjs","../node_modules/motion-dom/dist/es/animation/keyframes/get-final.mjs","../node_modules/motion-dom/dist/es/animation/utils/replace-transition-type.mjs","../node_modules/motion-dom/dist/es/animation/utils/WithPromise.mjs","../node_modules/motion-dom/dist/es/animation/JSAnimation.mjs","../node_modules/motion-utils/dist/es/memo.mjs","../node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../node_modules/motion-dom/dist/es/utils/supports/flags.mjs","../node_modules/motion-dom/dist/es/utils/supports/memo.mjs","../node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs","../node_modules/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs","../node_modules/motion-dom/dist/es/animation/waapi/easing/supported.mjs","../node_modules/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs","../node_modules/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs","../node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs","../node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs","../node_modules/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs","../node_modules/motion-dom/dist/es/render/dom/style-set.mjs","../node_modules/motion-dom/dist/es/render/dom/is-css-var.mjs","../node_modules/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs","../node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs","../node_modules/motion-dom/dist/es/animation/utils/is-animatable.mjs","../node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs","../node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs","../node_modules/motion-dom/dist/es/animation/utils/can-animate.mjs","../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","../node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","../node_modules/framer-motion/dist/es/animation/utils/calc-child-stagger.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs","../node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs","../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","../node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","../node_modules/framer-motion/dist/es/motion/features/Feature.mjs","../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs","../node_modules/framer-motion/dist/es/motion/features/animations.mjs","../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs","../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs","../node_modules/framer-motion/dist/es/events/add-dom-event.mjs","../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs","../node_modules/framer-motion/dist/es/events/event-info.mjs","../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs","../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs","../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs","../node_modules/framer-motion/dist/es/utils/get-context-window.mjs","../node_modules/framer-motion/dist/es/utils/distance.mjs","../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs","../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs","../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs","../node_modules/framer-motion/dist/es/gestures/pan/index.mjs","../node_modules/framer-motion/dist/es/projection/node/state.mjs","../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs","../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs","../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs","../node_modules/motion-dom/dist/es/utils/is-svg-element.mjs","../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs","../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs","../node_modules/framer-motion/dist/es/utils/delay.mjs","../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs","../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs","../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs","../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs","../node_modules/framer-motion/dist/es/projection/shared/stack.mjs","../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs","../node_modules/motion-dom/dist/es/utils/is-svg-svg-element.mjs","../node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","../node_modules/framer-motion/dist/es/projection/styles/transform.mjs","../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs","../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs","../node_modules/framer-motion/dist/es/motion/features/drag.mjs","../node_modules/framer-motion/dist/es/gestures/drag/index.mjs","../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs","../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs","../node_modules/motion-dom/dist/es/gestures/hover.mjs","../node_modules/framer-motion/dist/es/gestures/hover.mjs","../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs","../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs","../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs","../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs","../node_modules/motion-dom/dist/es/gestures/press/index.mjs","../node_modules/framer-motion/dist/es/gestures/press.mjs","../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs","../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","../node_modules/framer-motion/dist/es/motion/features/gestures.mjs","../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs","../node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs","../node_modules/framer-motion/dist/es/gestures/focus.mjs","../node_modules/framer-motion/dist/es/motion/features/layout.mjs","../node_modules/@kurkle/color/dist/color.esm.js","../node_modules/chart.js/src/helpers/helpers.core.ts","../node_modules/chart.js/src/helpers/helpers.math.ts","../node_modules/chart.js/src/helpers/helpers.collection.ts","../node_modules/chart.js/src/helpers/helpers.extras.ts","../node_modules/chart.js/src/helpers/helpers.easing.ts","../node_modules/chart.js/src/helpers/helpers.color.ts","../node_modules/chart.js/src/core/core.animations.defaults.js","../node_modules/chart.js/src/helpers/helpers.intl.ts","../node_modules/chart.js/src/core/core.ticks.js","../node_modules/chart.js/src/core/core.defaults.js","../node_modules/chart.js/src/core/core.layouts.defaults.js","../node_modules/chart.js/src/core/core.scale.defaults.js","../node_modules/chart.js/src/helpers/helpers.canvas.ts","../node_modules/chart.js/src/helpers/helpers.options.ts","../node_modules/chart.js/src/helpers/helpers.config.ts","../node_modules/chart.js/src/helpers/helpers.curve.ts","../node_modules/chart.js/src/helpers/helpers.dom.ts","../node_modules/chart.js/src/helpers/helpers.interpolation.ts","../node_modules/chart.js/src/helpers/helpers.rtl.ts","../node_modules/chart.js/src/helpers/helpers.segment.js","../node_modules/chart.js/src/helpers/helpers.dataset.ts","../node_modules/chart.js/src/core/core.animator.js","../node_modules/chart.js/src/core/core.animation.js","../node_modules/chart.js/src/core/core.animations.js","../node_modules/chart.js/src/core/core.datasetController.js","../node_modules/chart.js/src/controllers/controller.bar.js","../node_modules/chart.js/src/controllers/controller.bubble.js","../node_modules/chart.js/src/controllers/controller.doughnut.js","../node_modules/chart.js/src/controllers/controller.line.js","../node_modules/chart.js/src/controllers/controller.polarArea.js","../node_modules/chart.js/src/controllers/controller.pie.js","../node_modules/chart.js/src/controllers/controller.radar.js","../node_modules/chart.js/src/controllers/controller.scatter.js","../node_modules/chart.js/src/core/core.adapters.ts","../node_modules/chart.js/src/core/core.interaction.js","../node_modules/chart.js/src/core/core.layouts.js","../node_modules/chart.js/src/platform/platform.base.js","../node_modules/chart.js/src/platform/platform.basic.js","../node_modules/chart.js/src/platform/platform.dom.js","../node_modules/chart.js/src/core/core.element.ts","../node_modules/chart.js/src/core/core.scale.autoskip.js","../node_modules/chart.js/src/core/core.scale.js","../node_modules/chart.js/src/core/core.typedRegistry.js","../node_modules/chart.js/src/core/core.registry.js","../node_modules/chart.js/src/core/core.plugins.js","../node_modules/chart.js/src/core/core.config.js","../node_modules/chart.js/src/core/core.controller.js","../node_modules/chart.js/src/platform/index.js","../node_modules/chart.js/src/elements/element.arc.ts","../node_modules/chart.js/src/elements/element.line.js","../node_modules/chart.js/src/elements/element.point.ts","../node_modules/chart.js/src/elements/element.bar.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","../node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","../node_modules/chart.js/src/plugins/plugin.filler/index.js","../node_modules/chart.js/src/plugins/plugin.legend.js","../node_modules/chart.js/src/plugins/plugin.title.js","../node_modules/chart.js/src/plugins/plugin.subtitle.js","../node_modules/chart.js/src/plugins/plugin.tooltip.js","../node_modules/chart.js/src/scales/scale.category.js","../node_modules/chart.js/src/scales/scale.linearbase.js","../node_modules/chart.js/src/scales/scale.linear.js","../node_modules/chart.js/src/scales/scale.logarithmic.js","../node_modules/chart.js/src/scales/scale.radialLinear.js","../node_modules/chart.js/src/scales/scale.time.js","../node_modules/motion-utils/dist/es/is-object.mjs","../node_modules/motion-dom/dist/es/utils/is-html-element.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","../node_modules/framer-motion/dist/es/context/PresenceContext.mjs"],"sourcesContent":["import { useLayoutEffect, useEffect } from 'react';\nimport { isBrowser } from './is-browser.mjs';\n\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\n\nexport { useIsomorphicLayoutEffect };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst MotionConfigContext = createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\nexport { MotionConfigContext };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LayoutGroupContext = createContext({});\n\nexport { LayoutGroupContext };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX, root }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = useContext(MotionConfigContext);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        if (nonce)\n            style.nonce = nonce;\n        const parent = root ?? document.head;\n        parent.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style);\n            }\n        };\n    }, [isPresent]);\n    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) }));\n}\n\nexport { PopChild };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    let isReusedContext = true;\n    let context = useMemo(() => {\n        isReusedContext = false;\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId) => {\n                presenceChildren.set(childId, true);\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n                onExitComplete && onExitComplete();\n            },\n            register: (childId) => {\n                presenceChildren.set(childId, false);\n                return () => presenceChildren.delete(childId);\n            },\n        };\n    }, [isPresent, presenceChildren, onExitComplete]);\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context };\n    }\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { Children, isValidElement } from 'react';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\nexport { getChildKey, onlyElements };\n","\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", root }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, root: root, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n","const isBrowser = typeof window !== \"undefined\";\n\nexport { isBrowser };\n","import { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nexport { useConstant };\n","import type { MouseEvent } from 'react';\nimport type {\n  ChartType,\n  ChartData,\n  DefaultDataPoint,\n  ChartDataset,\n  ChartOptions,\n  Chart,\n} from 'chart.js';\n\nimport type { ForwardedRef } from './types.js';\n\nconst defaultDatasetIdKey = 'label';\n\nexport function reforwardRef<T>(ref: ForwardedRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nexport function setOptions<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(chart: Chart<TType, TData, TLabel>, nextOptions: ChartOptions<TType>) {\n  const options = chart.options;\n\n  if (options && nextOptions) {\n    Object.assign(options, nextOptions);\n  }\n}\n\nexport function setLabels<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(\n  currentData: ChartData<TType, TData, TLabel>,\n  nextLabels: TLabel[] | undefined\n) {\n  currentData.labels = nextLabels;\n}\n\nexport function setDatasets<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(\n  currentData: ChartData<TType, TData, TLabel>,\n  nextDatasets: ChartDataset<TType, TData>[],\n  datasetIdKey = defaultDatasetIdKey\n) {\n  const addedDatasets: ChartDataset<TType, TData>[] = [];\n\n  currentData.datasets = nextDatasets.map(\n    (nextDataset: Record<string, unknown>) => {\n      // given the new set, find it's current match\n      const currentDataset = currentData.datasets.find(\n        (dataset: Record<string, unknown>) =>\n          dataset[datasetIdKey] === nextDataset[datasetIdKey]\n      );\n\n      // There is no original to update, so simply add new one\n      if (\n        !currentDataset ||\n        !nextDataset.data ||\n        addedDatasets.includes(currentDataset)\n      ) {\n        return { ...nextDataset } as ChartDataset<TType, TData>;\n      }\n\n      addedDatasets.push(currentDataset);\n\n      Object.assign(currentDataset, nextDataset);\n\n      return currentDataset;\n    }\n  );\n}\n\nexport function cloneData<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(data: ChartData<TType, TData, TLabel>, datasetIdKey = defaultDatasetIdKey) {\n  const nextData: ChartData<TType, TData, TLabel> = {\n    labels: [],\n    datasets: [],\n  };\n\n  setLabels(nextData, data.labels);\n  setDatasets(nextData, data.datasets, datasetIdKey);\n\n  return nextData;\n}\n\n/**\n * Get dataset from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getDatasetAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'dataset',\n    { intersect: true },\n    false\n  );\n}\n\n/**\n * Get single dataset element from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getElementAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'nearest',\n    { intersect: true },\n    false\n  );\n}\n\n/**\n * Get all dataset elements from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getElementsAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'index',\n    { intersect: true },\n    false\n  );\n}\n","import React, { useEffect, useRef, forwardRef } from 'react';\nimport { Chart as ChartJS } from 'chart.js';\nimport type { ChartType, DefaultDataPoint } from 'chart.js';\n\nimport type { ForwardedRef, ChartProps, BaseChartComponent } from './types.js';\nimport {\n  reforwardRef,\n  cloneData,\n  setOptions,\n  setLabels,\n  setDatasets,\n} from './utils.js';\n\nfunction ChartComponent<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown,\n>(\n  props: ChartProps<TType, TData, TLabel>,\n  ref: ForwardedRef<ChartJS<TType, TData, TLabel>>\n) {\n  const {\n    height = 150,\n    width = 300,\n    redraw = false,\n    datasetIdKey,\n    type,\n    data,\n    options,\n    plugins = [],\n    fallbackContent,\n    updateMode,\n    ...canvasProps\n  } = props;\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const chartRef = useRef<ChartJS<TType, TData, TLabel> | null>(null);\n\n  const renderChart = () => {\n    if (!canvasRef.current) return;\n\n    chartRef.current = new ChartJS(canvasRef.current, {\n      type,\n      data: cloneData(data, datasetIdKey),\n      options: options && { ...options },\n      plugins,\n    });\n\n    reforwardRef(ref, chartRef.current);\n  };\n\n  const destroyChart = () => {\n    reforwardRef(ref, null);\n\n    if (chartRef.current) {\n      chartRef.current.destroy();\n      chartRef.current = null;\n    }\n  };\n\n  useEffect(() => {\n    if (!redraw && chartRef.current && options) {\n      setOptions(chartRef.current, options);\n    }\n  }, [redraw, options]);\n\n  useEffect(() => {\n    if (!redraw && chartRef.current) {\n      setLabels(chartRef.current.config.data, data.labels);\n    }\n  }, [redraw, data.labels]);\n\n  useEffect(() => {\n    if (!redraw && chartRef.current && data.datasets) {\n      setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);\n    }\n  }, [redraw, data.datasets]);\n\n  useEffect(() => {\n    if (!chartRef.current) return;\n\n    if (redraw) {\n      destroyChart();\n      setTimeout(renderChart);\n    } else {\n      chartRef.current.update(updateMode);\n    }\n  }, [redraw, options, data.labels, data.datasets, updateMode]);\n\n  useEffect(() => {\n    if (!chartRef.current) return;\n\n    destroyChart();\n    setTimeout(renderChart);\n  }, [type]);\n\n  useEffect(() => {\n    renderChart();\n\n    return () => destroyChart();\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      role='img'\n      height={height}\n      width={width}\n      {...canvasProps}\n    >\n      {fallbackContent}\n    </canvas>\n  );\n}\n\nexport const Chart = forwardRef(ChartComponent) as BaseChartComponent;\n","import React, { forwardRef } from 'react';\nimport {\n  Chart as ChartJS,\n  LineController,\n  BarController,\n  RadarController,\n  DoughnutController,\n  PolarAreaController,\n  BubbleController,\n  PieController,\n  ScatterController,\n} from 'chart.js';\nimport type { ChartType, ChartComponentLike } from 'chart.js';\n\nimport type {\n  ChartProps,\n  ChartJSOrUndefined,\n  TypedChartComponent,\n} from './types.js';\nimport { Chart } from './chart.js';\n\nfunction createTypedChart<T extends ChartType>(\n  type: T,\n  registerables: ChartComponentLike\n) {\n  ChartJS.register(registerables);\n\n  return forwardRef<ChartJSOrUndefined<T>, Omit<ChartProps<T>, 'type'>>(\n    (props, ref) => <Chart {...props} ref={ref} type={type} />\n  ) as TypedChartComponent<T>;\n}\n\nexport const Line = /* #__PURE__ */ createTypedChart('line', LineController);\n\nexport const Bar = /* #__PURE__ */ createTypedChart('bar', BarController);\n\nexport const Radar = /* #__PURE__ */ createTypedChart('radar', RadarController);\n\nexport const Doughnut = /* #__PURE__ */ createTypedChart(\n  'doughnut',\n  DoughnutController\n);\n\nexport const PolarArea = /* #__PURE__ */ createTypedChart(\n  'polarArea',\n  PolarAreaController\n);\n\nexport const Bubble = /* #__PURE__ */ createTypedChart(\n  'bubble',\n  BubbleController\n);\n\nexport const Pie = /* #__PURE__ */ createTypedChart('pie', PieController);\n\nexport const Scatter = /* #__PURE__ */ createTypedChart(\n  'scatter',\n  ScatterController\n);\n","/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = /*@__PURE__*/ (() => new Set(transformPropOrder))();\n\nexport { transformPropOrder, transformProps };\n","const radToDeg = (rad) => (rad * 180) / Math.PI;\nconst rotate = (v) => {\n    const angle = radToDeg(Math.atan2(v[1], v[0]));\n    return rebaseAngle(angle);\n};\nconst matrix2dParsers = {\n    x: 4,\n    y: 5,\n    translateX: 4,\n    translateY: 5,\n    scaleX: 0,\n    scaleY: 3,\n    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,\n    rotate,\n    rotateZ: rotate,\n    skewX: (v) => radToDeg(Math.atan(v[1])),\n    skewY: (v) => radToDeg(Math.atan(v[2])),\n    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2,\n};\nconst rebaseAngle = (angle) => {\n    angle = angle % 360;\n    if (angle < 0)\n        angle += 360;\n    return angle;\n};\nconst rotateZ = rotate;\nconst scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);\nconst scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);\nconst matrix3dParsers = {\n    x: 12,\n    y: 13,\n    z: 14,\n    translateX: 12,\n    translateY: 13,\n    translateZ: 14,\n    scaleX,\n    scaleY,\n    scale: (v) => (scaleX(v) + scaleY(v)) / 2,\n    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),\n    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),\n    rotateZ,\n    rotate: rotateZ,\n    skewX: (v) => radToDeg(Math.atan(v[4])),\n    skewY: (v) => radToDeg(Math.atan(v[1])),\n    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2,\n};\nfunction defaultTransformValue(name) {\n    return name.includes(\"scale\") ? 1 : 0;\n}\nfunction parseValueFromTransform(transform, name) {\n    if (!transform || transform === \"none\") {\n        return defaultTransformValue(name);\n    }\n    const matrix3dMatch = transform.match(/^matrix3d\\(([-\\d.e\\s,]+)\\)$/u);\n    let parsers;\n    let match;\n    if (matrix3dMatch) {\n        parsers = matrix3dParsers;\n        match = matrix3dMatch;\n    }\n    else {\n        const matrix2dMatch = transform.match(/^matrix\\(([-\\d.e\\s,]+)\\)$/u);\n        parsers = matrix2dParsers;\n        match = matrix2dMatch;\n    }\n    if (!match) {\n        return defaultTransformValue(name);\n    }\n    const valueParser = parsers[name];\n    const values = match[1].split(\",\").map(convertTransformToNumber);\n    return typeof valueParser === \"function\"\n        ? valueParser(values)\n        : values[valueParser];\n}\nconst readTransformValue = (instance, name) => {\n    const { transform = \"none\" } = getComputedStyle(instance);\n    return parseValueFromTransform(transform, name);\n};\nfunction convertTransformToNumber(value) {\n    return parseFloat(value.trim());\n}\n\nexport { defaultTransformValue, parseValueFromTransform, readTransformValue };\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\nexport { isCSSVariableName, isCSSVariableToken };\n","/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nexport { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };\n","/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\nexport { mixNumber };\n","function isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY ||\n        values.skewX ||\n        values.skewY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\nexport { has2DTranslate, hasScale, hasTransform };\n","import { mixNumber } from 'motion-dom';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n","import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';\nimport { translateAxis } from '../geometry/delta-apply.mjs';\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\nexport { measurePageBox, measureViewportBox };\n","import { transformPropOrder } from './keys-transform.mjs';\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    ...transformPropOrder,\n]);\n\nexport { positionalKeys };\n","const clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexport { clamp };\n","import { clamp } from 'motion-utils';\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\nexport { alpha, number, scale };\n","/*#__NO_SIDE_EFFECTS__*/\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = /*@__PURE__*/ (() => ({\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n}))();\n\nexport { degrees, percent, progressPercentage, px, vh, vw };\n","/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\nexport { testValueType };\n","import { auto } from './auto.mjs';\nimport { number } from './numbers/index.mjs';\nimport { px, percent, degrees, vw, vh } from './numbers/units.mjs';\nimport { testValueType } from './test.mjs';\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\nexport { dimensionValueTypes, findDimensionValueType };\n","/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\nexport { auto };\n","/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\nexport { isNumericalString };\n","import { invariant, isNumericalString } from 'motion-utils';\nimport { isCSSVariableToken } from './is-css-variable.mjs';\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = \n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token1, token2, fallback] = match;\n    return [`--${token1 ?? token2}`, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`, \"max-css-var-depth\");\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback)\n        ? getVariableValue(fallback, element, depth + 1)\n        : fallback;\n}\n\nexport { getVariableValue, parseCSSVariable };\n","import { parseValueFromTransform } from '../../../render/dom/parse-transform.mjs';\nimport { transformPropOrder } from '../../../render/utils/keys-transform.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: (_bbox, { transform }) => parseValueFromTransform(transform, \"x\"),\n    y: (_bbox, { transform }) => parseValueFromTransform(transform, \"y\"),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n","const MotionGlobalConfig = {};\n\nexport { MotionGlobalConfig };\n","const stepsOrder = [\n    \"setup\", // Compute\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"preUpdate\", // Compute\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\n\nexport { stepsOrder };\n","const statsBuffer = {\n    value: null,\n    addProjectionMetrics: null,\n};\n\nexport { statsBuffer };\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { stepsOrder } from './order.mjs';\nimport { createRenderStep } from './render-step.mjs';\n\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\n        return acc;\n    }, {});\n    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender, } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        if (!MotionGlobalConfig.useManualTiming) {\n            state.delta = useDefaultElapsed\n                ? 1000 / 60\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        }\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        setup.process(state);\n        read.process(state);\n        resolveKeyframes.process(state);\n        preUpdate.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nexport { createRenderBatcher };\n","import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n","import { noop } from 'motion-utils';\nimport { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\nexport { cancelFrame, frame, frameData, frameSteps };\n","import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete(isForced));\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    isForced = true;\n    readAllKeyframes();\n    measureAllKeyframes();\n    isForced = false;\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        this.state = \"pending\";\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.state = \"scheduled\";\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get();\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue;\n            }\n            else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe);\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead;\n                }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0]);\n            }\n        }\n        fillWildcards(unresolvedKeyframes);\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete(isForcedComplete = false) {\n        this.state = \"complete\";\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (this.state === \"scheduled\") {\n            toResolve.delete(this);\n            this.state = \"pending\";\n        }\n    }\n    resume() {\n        if (this.state === \"pending\")\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n","function fillWildcards(keyframes) {\n    for (let i = 1; i < keyframes.length; i++) {\n        keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);\n    }\n}\n\nexport { fillWildcards };\n","/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\nexport { isZeroValueString };\n","import { isZeroValueString } from 'motion-utils';\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\nexport { isNone };\n","// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\nexport { sanitize };\n","const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\nexport { floatRegex };\n","const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\nexport { singleColorRegex };\n","import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === \"string\" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== \"string\")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nexport { isColorString, splitColor };\n","function isNullish(v) {\n    return v == null;\n}\n\nexport { isNullish };\n","import { clamp } from 'motion-utils';\nimport { number, alpha } from '../numbers/index.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nexport { rgbUnit, rgba };\n","import { rgba } from './rgba.mjs';\nimport { isColorString } from './utils.mjs';\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nexport { hex };\n","import { alpha } from '../numbers/index.mjs';\nimport { percent } from '../numbers/units.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nexport { hsla };\n","import { hex } from './hex.mjs';\nimport { hsla } from './hsla.mjs';\nimport { rgba } from './rgba.mjs';\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === \"string\"\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n    getAnimatableNone: (v) => {\n        const parsed = color.parse(v);\n        parsed.alpha = 0;\n        return color.transform(parsed);\n    },\n};\n\nexport { color };\n","const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\nexport { colorRegex };\n","import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n    return (isNaN(v) &&\n        typeof v === \"string\" &&\n        (v.match(floatRegex)?.length || 0) +\n            (v.match(colorRegex)?.length || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n","import { complex } from './index.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    },\n};\n\nexport { filter };\n","import { number } from './numbers/index.mjs';\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nexport { int };\n","import { int } from '../int.mjs';\nimport { alpha } from '../numbers/index.mjs';\nimport { px } from '../numbers/units.mjs';\nimport { transformValueTypes } from './transform.mjs';\n\nconst numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n    ...transformValueTypes,\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nexport { numberValueTypes };\n","import { scale, alpha } from '../numbers/index.mjs';\nimport { degrees, px, progressPercentage } from '../numbers/units.mjs';\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\nexport { transformValueTypes };\n","import { color } from '../color/index.mjs';\nimport { filter } from '../complex/filter.mjs';\nimport { numberValueTypes } from './number.mjs';\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nexport { defaultValueTypes, getDefaultValueType };\n","import { complex } from '../complex/index.mjs';\nimport { filter } from '../complex/filter.mjs';\nimport { getDefaultValueType } from '../maps/defaults.mjs';\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\nexport { getAnimatableNone };\n","import { analyseComplexValue } from '../../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../../../value/types/utils/animatable-none.mjs';\n\n/**\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\n */\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\" &&\n            !invalidTemplates.has(keyframe) &&\n            analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\n\nexport { makeNoneKeyframesAnimatable };\n","import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else if (positionalValues[name]) {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n","const isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nexport { isMotionValue };\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { frameData } from './frame.mjs';\n\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n    now: () => {\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\n                ? frameData.timestamp\n                : performance.now());\n        }\n        return now;\n    },\n    set: (newTime) => {\n        now = newTime;\n        queueMicrotask(clearTime);\n    },\n};\n\nexport { time };\n","function addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nexport { addUniqueItem, moveItem, removeItem };\n","import { addUniqueItem, removeItem } from './array.mjs';\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\nexport { SubscriptionManager };\n","/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n","import { warnOnce, SubscriptionManager, velocityPerSecond } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     */\n    constructor(init, options = {}) {\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = null;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v) => {\n            const currentTime = time.now();\n            /**\n             * If we're updating the value during another frame or eventloop\n             * than the previous frame, then the we set the previous frame value\n             * to current.\n             */\n            if (this.updatedAt !== currentTime) {\n                this.setPrevFrameValue();\n            }\n            this.prev = this.current;\n            this.setCurrent(v);\n            // Update update subscribers\n            if (this.current !== this.prev) {\n                this.events.change?.notify(this.current);\n                if (this.dependents) {\n                    for (const dependent of this.dependents) {\n                        dependent.dirty();\n                    }\n                }\n            }\n        };\n        this.hasAnimated = false;\n        this.setCurrent(init);\n        this.owner = options.owner;\n    }\n    setCurrent(current) {\n        this.current = current;\n        this.updatedAt = time.now();\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current);\n        }\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n        this.prevFrameValue = prevFrameValue;\n        this.prevUpdatedAt = this.updatedAt;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v) {\n        if (!this.passiveEffect) {\n            this.updateAndNotify(v);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = undefined;\n        this.prevFrameValue = prev;\n        this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v, endAnimation = true) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\n        endAnimation && this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    dirty() {\n        this.events.change?.notify(this.current);\n    }\n    addDependent(dependent) {\n        if (!this.dependents) {\n            this.dependents = new Set();\n        }\n        this.dependents.add(dependent);\n    }\n    removeDependent(dependent) {\n        if (this.dependents) {\n            this.dependents.delete(dependent);\n        }\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now();\n        if (!this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n            return 0;\n        }\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n        // Casts because of parseFloat's poor typing\n        return velocityPerSecond(parseFloat(this.current) -\n            parseFloat(this.prevFrameValue), delta);\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.dependents?.clear();\n        this.events.destroy?.notify();\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\nexport { MotionValue, collectMotionValues, motionValue };\n","import { color } from '../color/index.mjs';\nimport { complex } from '../complex/index.mjs';\nimport { dimensionValueTypes } from '../dimensions.mjs';\nimport { testValueType } from '../test.mjs';\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\nexport { findValueType };\n","import { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: microtask, cancel: cancelMicrotask } = \n/* @__PURE__ */ createRenderBatcher(queueMicrotask, false);\n\nexport { cancelMicrotask, microtask };\n","const featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nexport { featureDefinitions };\n","const createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\nexport { createAxis, createAxisDelta, createBox, createDelta };\n","// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nexport { hasReducedMotionListener, prefersReducedMotion };\n","const visualElementStore = new WeakMap();\n\nexport { visualElementStore };\n","function isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nexport { isAnimationControls };\n","/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nexport { isVariantLabel };\n","const variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nexport { variantPriorityOrder, variantProps };\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nexport { isControllingVariants, isVariantNode };\n","function getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement?.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\nexport { resolveVariantFromProps };\n","import { KeyframeResolver, time, frame, isMotionValue, cancelFrame, transformProps, motionValue, findValueType, complex, getAnimatableNone, microtask } from 'motion-dom';\nimport { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key]);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n        }\n        this.parent?.addChild(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent?.removeChild(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    addChild(child) {\n        this.children.add(child);\n        this.enteringChildren ?? (this.enteringChildren = new Set());\n        this.enteringChildren.add(child);\n    }\n    removeChild(child) {\n        this.children.delete(child);\n        this.enteringChildren && this.enteringChildren.delete(child);\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform();\n        }\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n            this.scheduleRender();\n        });\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : this.getBaseTargetFromProps(this.props, key) ??\n                this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n    scheduleRenderMicrotask() {\n        microtask.render(this.render);\n    }\n}\n\nexport { VisualElement };\n","import { isBrowser } from '../is-browser.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addEventListener(\"change\", setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\nexport { initPrefersReducedMotion };\n","import { isMotionValue, motionValue } from 'motion-dom';\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nexport { updateMotionValuesFromProps };\n","import { DOMKeyframesResolver, isMotionValue } from 'motion-dom';\nimport { VisualElement } from '../VisualElement.mjs';\n\nclass DOMVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style\n            ? props.style[key]\n            : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n\nexport { DOMVisualElement };\n","/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nexport { getValueAsType };\n","import { transformPropOrder, getValueAsType, numberValueTypes } from 'motion-dom';\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nexport { buildTransform };\n","import { transformProps, isCSSVariableName, getValueAsType, numberValueTypes } from 'motion-dom';\nimport { buildTransform } from './build-transform.mjs';\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nexport { buildHTMLStyles };\n","function renderHTML(element, { style, vars }, styleProp, projection) {\n    const elementStyle = element.style;\n    let key;\n    for (key in style) {\n        // CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.\n        elementStyle[key] = style[key];\n    }\n    // Write projection styles directly to element style\n    projection?.applyProjectionStyles(elementStyle, styleProp);\n    for (key in vars) {\n        // Loop over any CSS variables and assign those.\n        // They can only be assigned using `setProperty`.\n        elementStyle.setProperty(key, vars[key]);\n    }\n}\n\nexport { renderHTML };\n","import { isCSSVariableName } from 'motion-dom';\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key];\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true;\n        }\n    }\n}\n\nexport { addScaleCorrector, scaleCorrectors };\n","import { transformProps } from 'motion-dom';\nimport { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nexport { isForcedMotionValue };\n","import { isMotionValue } from 'motion-dom';\nimport { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            visualElement?.getValue(key)?.liveStyle !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n","import { transformProps, defaultTransformValue, readTransformValue, isCSSVariableName } from 'motion-dom';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"html\";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            return this.projection?.isProjecting\n                ? defaultTransformValue(key)\n                : readTransformValue(instance, key);\n        }\n        else {\n            const computedStyle = getComputedStyle(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n}\n\nexport { HTMLVisualElement, getComputedStyle };\n","/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\n\nexport { camelToDash };\n","import { px } from 'motion-dom';\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\nexport { buildSVGPath };\n","import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\nimport { buildSVGPath } from './path.mjs';\n\n/**\n * Build SVG visual attributes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate, styleProp) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style } = state;\n    /**\n     * However, we apply transforms as CSS transforms.\n     * So if we detect a transform, transformOrigin we take it from attrs and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    if (style.transform || attrs.transformOrigin) {\n        style.transformOrigin = attrs.transformOrigin ?? \"50% 50%\";\n        delete attrs.transformOrigin;\n    }\n    if (style.transform) {\n        /**\n         * SVG's element transform-origin uses its own median as a reference.\n         * Therefore, transformBox becomes a fill-box\n         */\n        style.transformBox = styleProp?.transformBox ?? \"fill-box\";\n        delete attrs.transformBox;\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nexport { buildSVGAttrs };\n","/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nexport { camelCaseAttributes };\n","const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nexport { isSVGTag };\n","import { isMotionValue, transformPropOrder } from 'motion-dom';\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n","import { transformProps, getDefaultValueType } from 'motion-dom';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\nimport { camelToDash } from '../dom/utils/camel-to-dash.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { camelCaseAttributes } from './utils/camel-case-attrs.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\nimport { renderSVG } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"svg\";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\nexport { SVGVisualElement };\n","import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';\nimport { renderHTML } from '../../html/utils/render.mjs';\nimport { camelCaseAttributes } from './camel-case-attrs.mjs';\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nexport { renderSVG };\n","/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nexport { lowercaseSVGElements };\n","import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nexport { isSVGComponent };\n","import { Fragment } from 'react';\nimport { HTMLVisualElement } from '../html/HTMLVisualElement.mjs';\nimport { SVGVisualElement } from '../svg/SVGVisualElement.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\n\nconst createDomVisualElement = (Component, options) => {\n    return isSVGComponent(Component)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n            allowProjection: Component !== Fragment,\n        });\n};\n\nexport { createDomVisualElement };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LazyContext = createContext({ strict: false });\n\nexport { LazyContext };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst MotionContext = /* @__PURE__ */ createContext({});\n\nexport { MotionContext };\n","import { useContext, useMemo } from 'react';\nimport { MotionContext } from './index.mjs';\nimport { getCurrentTreeVariants } from './utils.mjs';\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\nexport { useCreateMotionContext };\n","import { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\nimport { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nexport { getCurrentTreeVariants };\n","const createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\nexport { createHtmlRenderState };\n","import { isMotionValue } from 'motion-dom';\nimport { useMemo } from 'react';\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\nexport { copyRawValuesOnly, useHTMLProps };\n","import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\nexport { createSvgRenderState };\n","import { useMemo } from 'react';\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\nexport { useSVGProps };\n","/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith(\"while\") ||\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\n        key.startsWith(\"layout\") ||\n        key.startsWith(\"onTap\") ||\n        key.startsWith(\"onPan\") ||\n        key.startsWith(\"onLayout\") ||\n        validMotionProps.has(key));\n}\n\nexport { isValidMotionProp };\n","import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (typeof isValidProp !== \"function\")\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n}\ncatch {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === \"values\" && typeof props.values === \"object\")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props[\"draggable\"] &&\n                key.startsWith(\"onDrag\"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\nexport { filterProps, loadExternalIsValidProp };\n","import { isMotionValue } from 'motion-dom';\nimport { Fragment, useMemo, createElement } from 'react';\nimport { useHTMLProps } from '../html/use-props.mjs';\nimport { useSVGProps } from '../svg/use-props.mjs';\nimport { filterProps } from './utils/filter-props.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\n\nfunction useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = false) {\n    const useVisualProps = isSVGComponent(Component)\n        ? useSVGProps\n        : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = Component !== Fragment ? { ...filteredProps, ...visualProps, ref } : {};\n    /**\n     * If component has been handed a motion value as its child,\n     * memoise its initial value and render that. Subsequent updates\n     * will be handled by the onChange handler\n     */\n    const { children } = props;\n    const renderedChildren = useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\n    return createElement(Component, {\n        ...elementProps,\n        children: renderedChildren,\n    });\n}\n\nexport { useRender };\n","import { isMotionValue } from 'motion-dom';\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    return isMotionValue(value) ? value.get() : value;\n}\n\nexport { resolveMotionValue };\n","import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    return state;\n}\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\n\nexport { makeUseVisualState };\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nconst useHTMLVisualState = /*@__PURE__*/ makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState,\n});\n\nexport { useHTMLVisualState };\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nconst useSVGVisualState = /*@__PURE__*/ makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    createRenderState: createSvgRenderState,\n});\n\nexport { useSVGVisualState };\n","const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\nexport { motionComponentSymbol };\n","function isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\nexport { isRefObject };\n","import { useCallback } from 'react';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return useCallback((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\nexport { useMotionRef };\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = createContext({});\n\nexport { SwitchLayoutGroupContext };\n","import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement =\n        createVisualElement ||\n            lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n        window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        visualElement.scheduleRenderMicrotask();\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n        /**\n         * Now we've finished triggering animations for this element we\n         * can wipe the enteringChildren set for the next render.\n         */\n        visualElement.enteringChildren = undefined;\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n","\"use client\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { useRender } from '../render/dom/use-render.mjs';\nimport { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';\nimport { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';\nimport { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    const useVisualState = isSVGComponent(Component)\n        ? useSVGVisualState\n        : useHTMLVisualState;\n    function MotionDOMComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));\n    }\n    MotionDOMComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${Component.displayName ?? Component.name ?? \"\"})`}`;\n    const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? warning(false, strictMessage, \"lazy-strict-mode\")\n            : invariant(false, strictMessage, \"lazy-strict-mode\");\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\nexport { createMotionComponent };\n","import { featureDefinitions } from './definitions.mjs';\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\nexport { loadFeatures };\n","import { warnOnce } from 'motion-utils';\nimport { createMotionComponent } from '../../motion/index.mjs';\n\nfunction createMotionProxy(preloadedFeatures, createVisualElement) {\n    if (typeof Proxy === \"undefined\") {\n        return createMotionComponent;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    const componentCache = new Map();\n    const factory = (Component, options) => {\n        return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);\n    };\n    /**\n     * Support for deprecated`motion(Component)` pattern\n     */\n    const deprecatedFactoryFunction = (Component, options) => {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\n        }\n        return factory(Component, options);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: (_target, key) => {\n            if (key === \"create\")\n                return factory;\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, createMotionComponent(key, undefined, preloadedFeatures, createVisualElement));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\nexport { createMotionProxy };\n","import { resolveVariantFromProps } from './resolve-variants.mjs';\n\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\n\nexport { resolveVariant };\n","function getValueTransition(transition, key) {\n    return (transition?.[key] ??\n        transition?.[\"default\"] ??\n        transition);\n}\n\nexport { getValueTransition };\n","const isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nexport { isKeyframesTarget };\n","import { motionValue } from 'motion-dom';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction resolveFinalValueInKeyframes(v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n\nexport { setTarget };\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { isWillChangeMotionValue } from './is.mjs';\n\nfunction addValueToWillChange(visualElement, key) {\n    const willChange = visualElement.getValue(\"willChange\");\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can't add the value to it.\n     */\n    if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key);\n    }\n    else if (!willChange && MotionGlobalConfig.WillChange) {\n        const newWillChange = new MotionGlobalConfig.WillChange(\"auto\");\n        visualElement.addValue(\"willChange\", newWillChange);\n        newWillChange.add(key);\n    }\n}\n\nexport { addValueToWillChange };\n","import { isMotionValue } from 'motion-dom';\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\nexport { isWillChangeMotionValue };\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\nexport { getOptimisedAppearId };\n","function makeAnimationInstant(options) {\n    options.duration = 0;\n    options.type === \"keyframes\";\n}\n\nexport { makeAnimationInstant };\n","/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nexport { pipe };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n","const activeAnimations = {\n    layout: 0,\n    mainThread: 0,\n    waapi: 0,\n};\n\nexport { activeAnimations };\n","// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nexport { hslaToRgba };\n","function mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\nexport { mixImmediate };\n","import { warning } from 'motion-utils';\nimport { hex } from '../../value/types/color/hex.mjs';\nimport { hsla } from '../../value/types/color/hsla.mjs';\nimport { hslaToRgba } from '../../value/types/color/hsla-to-rgba.mjs';\nimport { rgba } from '../../value/types/color/rgba.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber } from './number.mjs';\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`, \"color-not-animatable\");\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\nexport { invisibleValues, mixVisibility };\n","import { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = origin.values[originIndex] ?? 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, \"complex-values-different\");\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n","import { getMixer } from './complex.mjs';\nimport { mixNumber } from './number.mjs';\n\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" &&\n        typeof to === \"number\" &&\n        typeof p === \"number\") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\nexport { mix };\n","import { time } from '../../frameloop/sync-time.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\nexport { frameloopDriver };\n","const generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += Math.round(easing(i / (numPoints - 1)) * 10000) / 10000 + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nexport { generateLinearEasing };\n","/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nexport { calcGeneratorDuration, maxGeneratorDuration };\n","import { velocityPerSecond } from 'motion-utils';\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n","const springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\nexport { springDefaults };\n","import { warning, secondsToMilliseconds, clamp, millisecondsToSeconds } from 'motion-utils';\nimport { springDefaults } from './defaults.mjs';\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\", \"spring-duration-limit\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring };\n","import { millisecondsToSeconds, secondsToMilliseconds, clamp } from 'motion-utils';\nimport { generateLinearEasing } from '../../waapi/utils/linear.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';\nimport { createGeneratorEasing } from '../utils/create-generator-easing.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = t === 0 ? initialVelocity : 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n        toTransition: () => { },\n    };\n    return generator;\n}\nspring.applyToOptions = (options) => {\n    const generatorOptions = createGeneratorEasing(options, 100, spring);\n    options.ease = generatorOptions.ease;\n    options.duration = secondsToMilliseconds(generatorOptions.duration);\n    options.type = \"keyframes\";\n    return options;\n};\n\nexport { spring };\n","import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n","import { millisecondsToSeconds } from 'motion-utils';\nimport { calcGeneratorDuration, maxGeneratorDuration } from './calc-duration.mjs';\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => {\n            return generator.next(duration * progress).value / scale;\n        },\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\nexport { createGeneratorEasing };\n","import { noop } from '../noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from Gatan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticeably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { cubicBezier } from './cubic-bezier.mjs';\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\nexport { easeIn, easeInOut, easeOut };\n","// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nexport { mirrorEasing };\n","// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nexport { reverseEasing };\n","import { cubicBezier } from './cubic-bezier.mjs';\nimport { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\nexport { backIn, backInOut, backOut };\n","import { backIn } from './back.mjs';\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nexport { anticipate };\n","import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\nexport { circIn, circInOut, circOut };\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nexport { isBezierDefinition };\n","import { invariant } from '../../errors.mjs';\nimport { noop } from '../../noop.mjs';\nimport { anticipate } from '../anticipate.mjs';\nimport { backIn, backInOut, backOut } from '../back.mjs';\nimport { circIn, circInOut, circOut } from '../circ.mjs';\nimport { cubicBezier } from '../cubic-bezier.mjs';\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\nimport { isBezierDefinition } from './is-bezier-definition.mjs';\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst isValidEasing = (easing) => {\n    return typeof easing === \"string\";\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, \"cubic-bezier-length\");\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (isValidEasing(definition)) {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`, \"invalid-easing-type\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nexport { easingDefinitionToFunction };\n","/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n","import { invariant, clamp, MotionGlobalConfig, noop, pipe, progress } from 'motion-utils';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\", \"range-length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n","import { fillOffset } from './fill.mjs';\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nexport { defaultOffset };\n","import { progress } from 'motion-utils';\nimport { mixNumber } from '../../../utils/mix/number.mjs';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\nexport { fillOffset };\n","import { easeInOut, isEasingArray, easingDefinitionToFunction } from 'motion-utils';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../keyframes/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../keyframes/offsets/time.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","const isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { isEasingArray };\n","function convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nexport { convertOffsetToTimes };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe, speed = 1) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const useFirstKeyframe = speed < 0 || (repeat && repeatType !== \"loop\" && repeat % 2 === 1);\n    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","import { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\n\nconst transitionTypeMap = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nfunction replaceTransitionType(transition) {\n    if (typeof transition.type === \"string\") {\n        transition.type = transitionTypeMap[transition.type];\n    }\n}\n\nexport { replaceTransitionType };\n","class WithPromise {\n    constructor() {\n        this.updateFinished();\n    }\n    get finished() {\n        return this._finished;\n    }\n    updateFinished() {\n        this._finished = new Promise((resolve) => {\n            this.resolve = resolve;\n        });\n    }\n    notifyFinished() {\n        this.resolve();\n    }\n    /**\n     * Allows the animation to be awaited.\n     *\n     * @deprecated Use `finished` instead.\n     */\n    then(onResolve, onReject) {\n        return this.finished.then(onResolve, onReject);\n    }\n}\n\nexport { WithPromise };\n","import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/frame.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            this.options.onStop?.();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, \"spring-two-frames\");\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n        this.driver?.start(false);\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        this.options.onPlay?.();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.notifyFinished();\n        this.teardown();\n        this.state = \"finished\";\n        this.options.onComplete?.();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n        this.options.onCancel?.();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        this.driver?.stop();\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n","import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {};\n\nexport { supportsFlags };\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => supportsFlags[supportsFlag] ?? memoized();\n}\n\nexport { memoSupports };\n","import { memoSupports } from './memo.mjs';\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nexport { supportsLinearEasing };\n","const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { cubicBezierAsString };\n","import { cubicBezierAsString } from './cubic-bezier.mjs';\n\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\n\nexport { supportedWaapiEasing };\n","import { isBezierDefinition } from 'motion-utils';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { generateLinearEasing } from '../utils/linear.mjs';\nimport { cubicBezierAsString } from './cubic-bezier.mjs';\nimport { supportedWaapiEasing } from './supported.mjs';\n\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\") {\n        return supportsLinearEasing()\n            ? generateLinearEasing(easing, duration)\n            : \"ease-out\";\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nexport { mapEasingToNativeEasing };\n","import { activeAnimations } from '../../stats/animation-count.mjs';\nimport { statsBuffer } from '../../stats/buffer.mjs';\nimport { mapEasingToNativeEasing } from './easing/map-easing.mjs';\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeOut\", times, } = {}, pseudoElement = undefined) {\n    const keyframeOptions = {\n        [valueName]: keyframes,\n    };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    if (statsBuffer.value) {\n        activeAnimations.waapi++;\n    }\n    const options = {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    };\n    if (pseudoElement)\n        options.pseudoElement = pseudoElement;\n    const animation = element.animate(keyframeOptions, options);\n    if (statsBuffer.value) {\n        animation.finished.finally(() => {\n            activeAnimations.waapi--;\n        });\n    }\n    return animation;\n}\n\nexport { startWaapiAnimation };\n","function isGenerator(type) {\n    return typeof type === \"function\" && \"applyToOptions\" in type;\n}\n\nexport { isGenerator };\n","import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.finishedTime = null;\n        this.isStopped = false;\n        if (!options)\n            return;\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        this.options = options;\n        invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n        const transition = applyGeneratorOptions(options);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time;\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe);\n                }\n                else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe);\n                }\n                this.animation.cancel();\n            }\n            onComplete?.();\n            this.notifyFinished();\n        };\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        this.animation.play();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n        }\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish?.();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        if (this.updateMotionValue) {\n            this.updateMotionValue();\n        }\n        else {\n            this.commitStyles();\n        }\n        if (!this.isPseudoElement)\n            this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.finishedTime = null;\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0)\n            this.finishedTime = null;\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState;\n    }\n    get startTime() {\n        return Number(this.animation.startTime);\n    }\n    set startTime(newStartTime) {\n        this.animation.startTime = newStartTime;\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }) {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n        this.animation.onfinish = null;\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline;\n            return noop;\n        }\n        else {\n            return observe(this);\n        }\n    }\n}\n\nexport { NativeAnimation };\n","import { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\n\nfunction applyGeneratorOptions({ type, ...options }) {\n    if (isGenerator(type) && supportsLinearEasing()) {\n        return type.applyToOptions(options);\n    }\n    else {\n        options.duration ?? (options.duration = 300);\n        options.ease ?? (options.ease = \"easeOut\");\n    }\n    return options;\n}\n\nexport { applyGeneratorOptions };\n","import { isCSSVar } from './is-css-var.mjs';\n\nfunction setStyle(element, name, value) {\n    isCSSVar(name)\n        ? element.style.setProperty(name, value)\n        : (element.style[name] = value);\n}\n\nexport { setStyle };\n","const isCSSVar = (name) => name.startsWith(\"--\");\n\nexport { isCSSVar };\n","import { anticipate, backInOut, circInOut } from 'motion-utils';\n\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nfunction replaceStringEasing(transition) {\n    if (typeof transition.ease === \"string\" &&\n        isUnsupportedEase(transition.ease)) {\n        transition.ease = unsupportedEasingFunctions[transition.ease];\n    }\n}\n\nexport { replaceStringEasing };\n","import { secondsToMilliseconds } from 'motion-utils';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { NativeAnimation } from './NativeAnimation.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { replaceStringEasing } from './waapi/utils/unsupported-easing.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\nclass NativeAnimationExtended extends NativeAnimation {\n    constructor(options) {\n        /**\n         * The base NativeAnimation function only supports a subset\n         * of Motion easings, and WAAPI also only supports some\n         * easing functions via string/cubic-bezier definitions.\n         *\n         * This function replaces those unsupported easing functions\n         * with a JS easing function. This will later get compiled\n         * to a linear() easing function.\n         */\n        replaceStringEasing(options);\n        /**\n         * Ensure we replace the transition type with a generator function\n         * before passing to WAAPI.\n         *\n         * TODO: Does this have a better home? It could be shared with\n         * JSAnimation.\n         */\n        replaceTransitionType(options);\n        super(options);\n        if (options.startTime) {\n            this.startTime = options.startTime;\n        }\n        this.options = options;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    updateMotionValue(value) {\n        const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n        if (!motionValue)\n            return;\n        if (value !== undefined) {\n            motionValue.set(value);\n            return;\n        }\n        const sampleAnimation = new JSAnimation({\n            ...options,\n            autoplay: false,\n        });\n        const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        sampleAnimation.stop();\n    }\n}\n\nexport { NativeAnimationExtended };\n","import { complex } from '../../value/types/complex/index.mjs';\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys that might be non-animatable grows, replace with Set\n    if (name === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nexport { isAnimatable };\n","import { memo } from 'motion-utils';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Could be re-enabled now we have support for linear() easing\n    // \"background-color\"\n]);\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\nfunction supportsBrowserAnimation(options) {\n    const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n    const subject = motionValue?.owner?.current;\n    /**\n     * We use this check instead of isHTMLElement() because we explicitly\n     * **don't** want elements in different timing contexts (i.e. popups)\n     * to be accelerated, as it's not possible to sync these animations\n     * properly with those driven from the main window frameloop.\n     */\n    if (!(subject instanceof HTMLElement)) {\n        return false;\n    }\n    const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n    return (supportsWaapi() &&\n        name &&\n        acceleratedValues.has(name) &&\n        (name !== \"transform\" || !transformTemplate) &&\n        /**\n         * If we're outputting values to onUpdate then we can't use WAAPI as there's\n         * no way to read the value from WAAPI every frame.\n         */\n        !onUpdate &&\n        !repeatDelay &&\n        repeatType !== \"mirror\" &&\n        damping !== 0 &&\n        type !== \"inertia\");\n}\n\nexport { supportsBrowserAnimation };\n","import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            this.keyframeResolver?.cancel();\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            makeAnimationInstant(options);\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            this.keyframeResolver?.resume();\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel();\n        }\n        this.keyframeResolver?.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n","import { warning } from 'motion-utils';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren't traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === \"display\" || name === \"visibility\")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". \"${isOriginAnimatable ? targetKeyframe : originKeyframe}\" is not an animatable value.`, \"value-not-animatable\");\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === \"spring\" || isGenerator(type)) && velocity));\n}\n\nexport { canAnimate };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","import { transformProps } from 'motion-dom';\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\nexport { getDefaultTransition };\n","import { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        makeAnimationInstant(options);\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (MotionGlobalConfig.instantAnimations ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        makeAnimationInstant(options);\n        options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            return;\n        }\n    }\n    return valueTransition.isSync\n        ? new JSAnimation(options)\n        : new AsyncMotionValueAnimation(options);\n};\n\nexport { animateMotionValue };\n","/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\nexport { isTransitionDefined };\n","import { getValueTransition, frame, positionalKeys } from 'motion-dom';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If the value is already at the defined target, skip the animation.\n         */\n        const currentValue = value.get();\n        if (currentValue !== undefined &&\n            !value.isAnimating &&\n            !Array.isArray(valueTarget) &&\n            valueTarget === currentValue &&\n            !valueTransition.velocity) {\n            continue;\n        }\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n","function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {\n    const index = Array.from(children)\n        .sort((a, b) => a.sortNodePosition(b))\n        .indexOf(child);\n    const numChildren = children.size;\n    const maxStaggerDuration = (numChildren - 1) * staggerChildren;\n    const delayIsFunction = typeof delayChildren === \"function\";\n    return delayIsFunction\n        ? delayChildren(index, numChildren)\n        : staggerDirection === 1\n            ? index * staggerChildren\n            : maxStaggerDuration - index * staggerChildren;\n}\n\nexport { calcChildStagger };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { calcChildStagger } from '../utils/calc-child-stagger.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? visualElement.presenceContext?.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delay = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    for (const child of visualElement.variantChildren) {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delay +\n                (typeof delayChildren === \"function\" ? 0 : delayChildren) +\n                calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    }\n    return Promise.all(animations);\n}\n\nexport { animateVariant };\n","function shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nexport { shallowCompare };\n","import { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement)\n        return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent\n            ? getVariantContext(visualElement.parent) || {}\n            : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\n\nexport { getVariantContext };\n","import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { calcChildStagger } from '../../animation/utils/calc-child-stagger.mjs';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => {\n                    const options = { type };\n                    /**\n                     * If we're performing the initial animation, but we're not\n                     * rendering at the same time as the variant-controlling parent,\n                     * we want to use the parent's transition to calculate the stagger.\n                     */\n                    if (typeof animation === \"string\" &&\n                        isInitialRender &&\n                        !willAnimateViaParent &&\n                        visualElement.manuallyAnimateOnMount &&\n                        visualElement.parent) {\n                        const { parent } = visualElement;\n                        const parentVariant = resolveVariant(parent, animation);\n                        if (parent.enteringChildren && parentVariant) {\n                            const { delayChildren } = parentVariant.transition || {};\n                            options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);\n                        }\n                    }\n                    return {\n                        animation: animation,\n                        options,\n                    };\n                }));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\n                    ? props.initial[0]\n                    : props.initial);\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition;\n                }\n            }\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget ?? null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nimport { animateVariant } from './visual-element-variant.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify(\"AnimationComplete\", definition);\n    });\n}\n\nexport { animateVisualElement };\n","class Feature {\n    constructor(node) {\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() { }\n}\n\nexport { Feature };\n","import { Feature } from '../Feature.mjs';\n\nlet id = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.id = id++;\n    }\n    update() {\n        if (!this.node.presenceContext)\n            return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => {\n                onExitComplete(this.id);\n            });\n        }\n    }\n    mount() {\n        const { register, onExitComplete } = this.node.presenceContext || {};\n        if (onExitComplete) {\n            onExitComplete(this.id);\n        }\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() { }\n}\n\nexport { ExitAnimationFeature };\n","import { AnimationFeature } from './animation/index.mjs';\nimport { ExitAnimationFeature } from './animation/exit.mjs';\n\nconst animations = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n};\n\nexport { animations };\n","import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';\nimport { createAnimationState } from '../../../render/utils/animation-state.mjs';\nimport { Feature } from '../Feature.mjs';\n\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node) {\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        this.node.animationState.reset();\n        this.unmountControls?.();\n    }\n}\n\nexport { AnimationFeature };\n","const isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\nexport { isDragActive, isDragging };\n","function addDomEvent(target, eventName, handler, options = { passive: true }) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n}\n\nexport { addDomEvent };\n","const isPrimaryPointer = (event) => {\n    if (event.pointerType === \"mouse\") {\n        return typeof event.button !== \"number\" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\nexport { isPrimaryPointer };\n","import { isPrimaryPointer } from 'motion-dom';\n\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    };\n}\nconst addPointerInfo = (handler) => {\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\nexport { addPointerInfo, extractEventInfo };\n","import { addDomEvent } from './add-dom-event.mjs';\nimport { addPointerInfo } from './event-info.mjs';\n\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\nexport { addPointerEvent };\n","import { mixNumber } from 'motion-dom';\n\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate =\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\n        isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if ((delta.translate >= TRANSLATE_MIN &&\n        delta.translate <= TRANSLATE_MAX) ||\n        isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\nexport { calcAxisDelta, calcBoxDelta, calcLength, calcRelativeAxis, calcRelativeAxisPosition, calcRelativeBox, calcRelativePosition, isNear };\n","function eachAxis(callback) {\n    return [callback(\"x\"), callback(\"y\")];\n}\n\nexport { eachAxis };\n","// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = ({ current }) => {\n    return current ? current.ownerDocument.defaultView : null;\n};\n\nexport { getContextWindow };\n","const distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nexport { distance, distance2D };\n","import { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursor.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.distanceThreshold = distanceThreshold;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n","import { mixNumber } from 'motion-dom';\nimport { progress, clamp } from 'motion-utils';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n","import { frame, mixNumber, setDragLock, percent } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { PanSession } from '../pan/PanSession.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\n\nconst elementDragControls = new WeakMap();\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        /**\n         * The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n         */\n        this.latestPointerEvent = null;\n        /**\n         * The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n         */\n        this.latestPanInfo = null;\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = setDragLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.latestPointerEvent = event;\n            this.latestPanInfo = info;\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, \"transform\");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive(\"whileDrag\", true);\n        };\n        const onMove = (event, info) => {\n            this.latestPointerEvent = event;\n            this.latestPanInfo = info;\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset);\n            this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => {\n            this.latestPointerEvent = event;\n            this.latestPanInfo = info;\n            this.stop(event, info);\n            this.latestPointerEvent = null;\n            this.latestPanInfo = null;\n        };\n        const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === \"paused\" &&\n            this.getAxisMotionValue(axis).animation?.play());\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            distanceThreshold,\n            contextWindow: getContextWindow(this.visualElement),\n        });\n    }\n    /**\n     * @internal\n     */\n    stop(event, panInfo) {\n        const finalEvent = event || this.latestPointerEvent;\n        const finalPanInfo = panInfo || this.latestPanInfo;\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging || !finalPanInfo || !finalEvent)\n            return;\n        const { velocity } = finalPanInfo;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));\n        }\n    }\n    /**\n     * @internal\n     */\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive(\"whileDrag\", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : this.visualElement.projection?.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\", \"drag-constraints-ref\");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());\n    }\n    getAnimationState(axis) {\n        return this.getAxisMotionValue(axis).animation?.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n","import { isDragging } from './is-active.mjs';\n\nfunction setDragLock(axis) {\n    if (axis === \"x\" || axis === \"y\") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\nexport { setDragLock };\n","import { frame } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { Feature } from '../../motion/features/Feature.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { PanSession } from './PanSession.mjs';\n\nconst asyncHandler = (handler) => (event, info) => {\n    if (handler) {\n        frame.postRender(() => handler(event, info));\n    }\n};\nclass PanGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.removePointerDownListener = noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n            contextWindow: getContextWindow(this.node),\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info) => {\n                delete this.session;\n                if (onPanEnd) {\n                    frame.postRender(() => onPanEnd(event, info));\n                }\n            },\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\n\nexport { PanGesture };\n","/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nconst globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\nexport { globalProjectionState };\n","import { px } from 'motion-dom';\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\nexport { correctBorderRadius, pixelsToPercent };\n","import { complex, mixNumber } from 'motion-dom';\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\nexport { correctBoxShadow };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { frame, microtask } from 'motion-dom';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false;\nclass MeasureLayoutWithContext extends Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            if (hasTakenAnySnapshot) {\n                projection.root.didUpdate();\n            }\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const { projection } = visualElement;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        hasTakenAnySnapshot = true;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined ||\n            prevProps.isPresent !== isPresent) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        hasTakenAnySnapshot = true;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an SVG element in a way\n * that works across iframes\n */\nfunction isSVGElement(element) {\n    return isObject(element) && \"ownerSVGElement\" in element;\n}\n\nexport { isSVGElement };\n","const compareByDepth = (a, b) => a.depth - b.depth;\n\nexport { compareByDepth };\n","import { addUniqueItem, removeItem } from 'motion-utils';\nimport { compareByDepth } from './compare-by-depth.mjs';\n\nclass FlatTree {\n    constructor() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n\nexport { FlatTree };\n","import { time, frame, cancelFrame } from 'motion-dom';\nimport { secondsToMilliseconds } from 'motion-utils';\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.setup(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\nfunction delayInSeconds(callback, timeout) {\n    return delay(callback, secondsToMilliseconds(timeout));\n}\n\nexport { delay, delayInSeconds };\n","import { mixNumber, percent, px } from 'motion-dom';\nimport { progress, circOut, noop } from 'motion-utils';\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n","/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n\nexport { copyAxisDeltaInto, copyAxisInto, copyBoxInto };\n","import { percent, mixNumber } from 'motion-dom';\nimport { scalePoint } from './delta-apply.mjs';\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\")\n        return;\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };\n","import { calcLength } from './delta-calc.mjs';\n\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return (Math.round(a.min) === Math.round(b.min) &&\n        Math.round(a.max) === Math.round(b.max));\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return (a.translate === b.translate &&\n        a.scale === b.scale &&\n        a.originPoint === b.originPoint);\n}\n\nexport { aspectRatio, axisDeltaEquals, axisEquals, axisEqualsRounded, boxEquals, boxEqualsRounded, isDeltaZero };\n","import { addUniqueItem, removeItem } from 'motion-utils';\n\nclass NodeStack {\n    constructor() {\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member) => node === member);\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        let prevLead;\n        for (let i = indexOfNode; i >= 0; i--) {\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node) => {\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete &&\n                    resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node) => {\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\n\nexport { NodeStack };\n","import { statsBuffer, isSVGElement, isSVGSVGElement, frame, getValueTransition, cancelFrame, time, frameData, frameSteps, microtask, activeAnimations, motionValue, mixNumber } from 'motion-dom';\nimport { SubscriptionManager, clamp, noop } from 'motion-utils';\nimport { animateSingleValue } from '../../animation/animate/single-value.mjs';\nimport { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\nimport { delay } from '../../utils/delay.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { mixValues } from '../animation/mix-values.mjs';\nimport { copyBoxInto, copyAxisDeltaInto } from '../geometry/copy.mjs';\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\nimport { calcLength, calcRelativePosition, calcRelativeBox, calcBoxDelta, isNear } from '../geometry/delta-calc.mjs';\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\nimport { createBox, createDelta } from '../geometry/models.mjs';\nimport { boxEqualsRounded, isDeltaZero, axisDeltaEquals, aspectRatio, boxEquals } from '../geometry/utils.mjs';\nimport { NodeStack } from '../shared/stack.mjs';\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\nimport { buildProjectionTransform } from '../styles/transform.mjs';\nimport { eachAxis } from '../utils/each-axis.mjs';\nimport { hasTransform, hasScale, has2DTranslate } from '../utils/has-transform.mjs';\nimport { globalProjectionState } from './state.mjs';\n\nconst metrics = {\n    nodes: 0,\n    calculatedTargetDeltas: 0,\n    calculatedProjections: 0,\n};\nconst transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nconst animationTarget = 1000;\nlet id = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode)\n        return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement)\n        return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent?.()) {\n            /**\n             * A unique ID generated for every projection node.\n             */\n            this.id = id++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */\n            this.animationId = 0;\n            this.animationCommitId = 0;\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */\n            this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */\n            this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */\n            this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */\n            this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = () => this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = () => {\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */\n            this.updateProjection = () => {\n                this.projectionUpdateScheduled = false;\n                /**\n                 * Reset debug counts. Manually resetting rather than creating a new\n                 * object each frame.\n                 */\n                if (statsBuffer.value) {\n                    metrics.nodes =\n                        metrics.calculatedTargetDeltas =\n                            metrics.calculatedProjections =\n                                0;\n                }\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n                if (statsBuffer.addProjectionMetrics) {\n                    statsBuffer.addProjectionMetrics(metrics);\n                }\n            };\n            /**\n             * Frame calculations\n             */\n            this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [...parent.path, parent] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for (let i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */\n        mount(instance) {\n            if (this.instance)\n                return;\n            this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (this.root.hasTreeAnimated && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                let innerWidth = 0;\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\n                // Set initial innerWidth in a frame.read callback to batch the read\n                frame.read(() => {\n                    innerWidth = window.innerWidth;\n                });\n                attachResizeListener(instance, () => {\n                    const newInnerWidth = window.innerWidth;\n                    if (newInnerWidth === innerWidth)\n                        return;\n                    innerWidth = newInnerWidth;\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) => {\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition ||\n                        visualElement.getDefaultTransition() ||\n                        defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    const hasTargetChanged = !this.targetLayout ||\n                        !boxEqualsRounded(this.targetLayout, newLayout);\n                    /*\n                     * Note: Disabled to fix relative animations always triggering new\n                     * layout animations. If this causes further issues, we can try\n                     * a different approach to detecting relative target changes.\n                     */\n                    // || hasRelativeLayoutChanged\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\n                    if (this.options.layoutRoot ||\n                        this.resumeFrom ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (hasTargetChanged || !this.currentAnimation))) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        const animationOptions = {\n                            ...getValueTransition(layoutTransition, \"layout\"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete,\n                        };\n                        if (visualElement.shouldReduceMotion ||\n                            this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                        /**\n                         * Set animation origin after starting animation to avoid layout jump\n                         * caused by stopping previous layout animation\n                         */\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            this.eventHandlers.clear();\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return (this.isAnimationBlocked ||\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\n                false);\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we're running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don't yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */\n            if (window.MotionCancelOptimisedAnimation &&\n                !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll(\"snapshot\");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout)\n                return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            /**\n             * If this is a repeat of didUpdate then ignore the animation.\n             */\n            if (this.animationId <= this.animationCommitId) {\n                this.nodes.forEach(clearIsLayoutDirty);\n                return;\n            }\n            this.animationCommitId = this.animationId;\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            else {\n                this.isUpdating = false;\n                /**\n                 * Write\n                 */\n                this.nodes.forEach(resetTransformStyle);\n                /**\n                 * Read ==================\n                 */\n                // Update layout measurements of updated children\n                this.nodes.forEach(updateLayout);\n                /**\n                 * Write\n                 */\n                // Notify listeners that the layout is updated\n                this.nodes.forEach(notifyLayoutUpdate);\n            }\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */\n            const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            frame.postRender(() => {\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                }\n                else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */\n        updateSnapshot() {\n            if (this.snapshot || !this.instance)\n                return;\n            this.snapshot = this.measure();\n            if (this.snapshot &&\n                !calcLength(this.snapshot.measuredBox.x) &&\n                !calcLength(this.snapshot.measuredBox.y)) {\n                this.snapshot = undefined;\n            }\n        }\n        updateLayout() {\n            if (!this.instance)\n                return;\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (let i = 0; i < this.path.length; i++) {\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement &&\n                visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = \"measure\") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll &&\n                this.scroll.animationId === this.root.animationId &&\n                this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement && this.instance) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform)\n                return;\n            const isResetRequested = this.isLayoutDirty ||\n                this.shouldResetTransform ||\n                this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                this.instance &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */\n            if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id,\n            };\n        }\n        measurePageBox() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if (this.scroll?.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent)\n                return;\n            /**\n             * If the parent target isn't up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */\n            if (this.relativeParent.resolvedRelativeTargetAt !==\n                frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */\n            const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don't use transform for this step of processing so we don't\n             * need to check whether any nodes have changed transform.\n             */\n            const canSkip = !(forceRecalculation ||\n                (isShared && this.isSharedProjectionDirty) ||\n                this.isProjectionDirty ||\n                this.parent?.isProjectionDirty ||\n                this.attemptToResolveRelativeTarget ||\n                this.root.updateBlockedByResize);\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    relativeParent.layout &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                this.relativeParent &&\n                this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    Boolean(relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !relativeParent.options.layoutScroll &&\n                    relativeParent.target &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * Increase debug counter for resolved target deltas\n             */\n            if (statsBuffer.value) {\n                metrics.calculatedTargetDeltas++;\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent ||\n                hasScale(this.parent.latestValues) ||\n                has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget ||\n                this.targetDelta ||\n                this.options.layoutRoot) &&\n                this.layout);\n        }\n        calcProjection() {\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can't skip.\n             */\n            if (this.isProjectionDirty || this.parent?.isProjectionDirty) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node's shared projection is dirty then\n             * we can't skip.\n             */\n            if (isShared &&\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */\n            const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn't have a target,\n             * use the layout as the target.\n             */\n            if (lead.layout &&\n                !lead.target &&\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don't have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */\n                if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            }\n            else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY ||\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n            /**\n             * Increase debug counter for recalculated projections\n             */\n            if (statsBuffer.value) {\n                metrics.calculatedProjections++;\n            }\n        }\n        hide() {\n            this.isVisible = false;\n            // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n            // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            this.options.visualElement?.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot ? snapshot.latestValues : {};\n            const mixedValues = { ...this.latestValues };\n            const targetDelta = createDelta();\n            if (!this.relativeParent ||\n                !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest) => {\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget &&\n                    this.relativeTargetOrigin &&\n                    this.layout &&\n                    this.relativeParent &&\n                    this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */\n                    if (prevRelativeTarget &&\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget)\n                        prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners(\"animationStart\");\n            this.currentAnimation?.stop();\n            this.resumingFrom?.currentAnimation?.stop();\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = frame.update(() => {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                activeAnimations.layout++;\n                this.motionValue || (this.motionValue = motionValue(0));\n                this.currentAnimation = animateSingleValue(this.motionValue, [0, 1000], {\n                    ...options,\n                    velocity: 0,\n                    isSync: true,\n                    onUpdate: (latest) => {\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onStop: () => {\n                        activeAnimations.layout--;\n                    },\n                    onComplete: () => {\n                        activeAnimations.layout--;\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    },\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners(\"animationComplete\");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            /**\n             * If we're only animating position, and this element isn't the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */\n            if (this !== lead &&\n                this.layout &&\n                layout &&\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\n                    ? config.shouldPreserveFollowOpacity(node)\n                    : undefined,\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            const { layoutId } = this.options;\n            return layoutId ? this.getStack()?.lead || this : this;\n        }\n        getPrevLead() {\n            const { layoutId } = this.options;\n            return layoutId ? this.getStack()?.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\n            const stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return;\n            // If there's no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don't have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */\n            const { latestValues } = visualElement;\n            if (latestValues.z ||\n                latestValues.rotate ||\n                latestValues.rotateX ||\n                latestValues.rotateY ||\n                latestValues.rotateZ ||\n                latestValues.skewX ||\n                latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there's no distorting values, we don't need to do any more.\n            if (!hasDistortingTransform)\n                return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for (let i = 0; i < transformAxes.length; i++) {\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for (const key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        applyProjectionStyles(targetStyle, // CSSStyleDeclaration - doesn't allow numbers to be assigned to properties\n        styleProp) {\n            if (!this.instance || this.isSVG)\n                return;\n            if (!this.isVisible) {\n                targetStyle.visibility = \"hidden\";\n                return;\n            }\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                targetStyle.visibility = \"\";\n                targetStyle.opacity = \"\";\n                targetStyle.pointerEvents =\n                    resolveMotionValue(styleProp?.pointerEvents) || \"\";\n                targetStyle.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, \"\")\n                    : \"none\";\n                return;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                if (this.options.layoutId) {\n                    targetStyle.opacity =\n                        this.latestValues.opacity !== undefined\n                            ? this.latestValues.opacity\n                            : 1;\n                    targetStyle.pointerEvents =\n                        resolveMotionValue(styleProp?.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    targetStyle.transform = transformTemplate\n                        ? transformTemplate({}, \"\")\n                        : \"none\";\n                    this.hasProjected = false;\n                }\n                return;\n            }\n            targetStyle.visibility = \"\";\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                transform = transformTemplate(valuesToRender, transform);\n            }\n            targetStyle.transform = transform;\n            const { x, y } = this.projectionDelta;\n            targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                targetStyle.opacity =\n                    lead === this\n                        ? valuesToRender.opacity ??\n                            this.latestValues.opacity ??\n                            1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we're not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */\n                targetStyle.opacity =\n                    lead === this\n                        ? valuesToRender.opacity !== undefined\n                            ? valuesToRender.opacity\n                            : \"\"\n                        : valuesToRender.opacityExit !== undefined\n                            ? valuesToRender.opacityExit\n                            : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (const key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */\n                const corrected = transform === \"none\"\n                    ? valuesToRender[key]\n                    : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for (let i = 0; i < num; i++) {\n                        targetStyle[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    // If this is a CSS variable, set it directly on the instance.\n                    // Replacing this function from creating styles to setting them\n                    // would be a good place to remove per frame object creation\n                    if (isCSSVariable) {\n                        this.options.visualElement.renderState.vars[key] = corrected;\n                    }\n                    else {\n                        targetStyle[key] = corrected;\n                    }\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                targetStyle.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp?.pointerEvents) || \"\"\n                        : \"none\";\n            }\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node) => node.currentAnimation?.stop());\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    const snapshot = node.resumeFrom?.snapshot || node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners(\"didUpdate\")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (animationType === \"size\") {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */\n                if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max =\n                        node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeLayoutChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeLayoutChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeLayoutChanged,\n        });\n    }\n    else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    /**\n     * Increase debug counter for nodes encountered this frame\n     */\n    if (statsBuffer.value) {\n        metrics.nodes++;\n    }\n    if (!node.parent)\n        return;\n    /**\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */\n    if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\n        node.parent.isProjectionDirty ||\n        node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty =\n        node.isSharedProjectionDirty =\n            node.isTransformDirty =\n                false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify(\"BeforeLayoutMeasure\");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber(delta.translate, 0, p);\n    output.scale = mixNumber(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber(from.min, to.min, p);\n    output.max = mixNumber(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nconst userAgentContains = (string) => typeof navigator !== \"undefined\" &&\n    navigator.userAgent &&\n    navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */\nconst roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\")\n    ? Math.round\n    : noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return (animationType === \"position\" ||\n        (animationType === \"preserve-aspect\" &&\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\n}\nfunction checkNodeWasScrollRoot(node) {\n    return node !== node.root && node.scroll?.wasRoot;\n}\n\nexport { cleanDirtyNodes, createProjectionNode, mixAxis, mixAxisDelta, mixBox, propagateDirtyNodes };\n","import { isSVGElement } from './is-svg-element.mjs';\n\n/**\n * Checks if an element is specifically an SVGSVGElement (the root SVG element)\n * in a way that works across iframes\n */\nfunction isSVGSVGElement(element) {\n    return isSVGElement(element) && element.tagName === \"svg\";\n}\n\nexport { isSVGSVGElement };\n","import { isMotionValue, motionValue } from 'motion-dom';\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\nexport { animateSingleValue };\n","function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = latestTransform?.z || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n","import { addDomEvent } from '../../events/add-dom-event.mjs';\nimport { createProjectionNode } from './create-projection-node.mjs';\n\nconst DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n    measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }),\n    checkIsScrollRoot: () => true,\n});\n\nexport { DocumentProjectionNode };\n","import { createProjectionNode } from './create-projection-node.mjs';\nimport { DocumentProjectionNode } from './DocumentProjectionNode.mjs';\n\nconst rootProjectionNode = {\n    current: undefined,\n};\nconst HTMLProjectionNode = createProjectionNode({\n    measureScroll: (instance) => ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }),\n    defaultParent: () => {\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value) => {\n        instance.style.transform = value !== undefined ? value : \"none\";\n    },\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\"),\n});\n\nexport { HTMLProjectionNode, rootProjectionNode };\n","import { DragGesture } from '../../gestures/drag/index.mjs';\nimport { PanGesture } from '../../gestures/pan/index.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\nimport { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\n\nconst drag = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nexport { drag };\n","import { Feature } from '../../motion/features/Feature.mjs';\nimport { noop } from 'motion-utils';\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\n\nclass DragGesture extends Feature {\n    constructor(node) {\n        super(node);\n        this.removeGroupControls = noop;\n        this.removeListeners = noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\n\nexport { DragGesture };\n","import { resolveElements } from '../../utils/resolve-elements.mjs';\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\nexport { setupGesture };\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            root = scope.current;\n        }\n        const elements = selectorCache?.[elementOrSelector] ??\n            root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nexport { resolveElements };\n","import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\n\nfunction isValidHover(event) {\n    return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = (enterEvent) => {\n        if (!isValidHover(enterEvent))\n            return;\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(target, enterEvent);\n        if (typeof onHoverEnd !== \"function\" || !target)\n            return;\n        const onPointerLeave = (leaveEvent) => {\n            if (!isValidHover(leaveEvent))\n                return;\n            onHoverEnd(leaveEvent);\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\n        };\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    };\n    elements.forEach((element) => {\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\nexport { hover };\n","import { hover, frame } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\n\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onHover\" + lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = hover(current, (_element, startEvent) => {\n            handleHoverEvent(this.node, startEvent, \"Start\");\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\");\n        });\n    }\n    unmount() { }\n}\n\nexport { HoverGesture };\n","/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nexport { isNodeOrChild };\n","const focusableElements = new Set([\n    \"BUTTON\",\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\",\n    \"A\",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\nexport { isElementKeyboardAccessible };\n","const isPressing = new WeakSet();\n\nexport { isPressing };\n","import { isPressing } from './state.mjs';\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== \"Enter\")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, \"down\");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n        });\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\n    });\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\nexport { enableKeyboardPress };\n","import { isHTMLElement } from '../../utils/is-html-element.mjs';\nimport { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n    const startPress = (startEvent) => {\n        const target = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent))\n            return;\n        isPressing.add(target);\n        const onPressEnd = onPressStart(target, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener(\"pointerup\", onPointerUp);\n            window.removeEventListener(\"pointercancel\", onPointerCancel);\n            if (isPressing.has(target)) {\n                isPressing.delete(target);\n            }\n            if (!isValidPressEvent(endEvent)) {\n                return;\n            }\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, target === window ||\n                target === document ||\n                options.useGlobalTarget ||\n                isNodeOrChild(target, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    };\n    targets.forEach((target) => {\n        const pointerDownTarget = options.useGlobalTarget ? window : target;\n        pointerDownTarget.addEventListener(\"pointerdown\", startPress, eventOptions);\n        if (isHTMLElement(target)) {\n            target.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions));\n            if (!isElementKeyboardAccessible(target) &&\n                !target.hasAttribute(\"tabindex\")) {\n                target.tabIndex = 0;\n            }\n        }\n    });\n    return cancelEvents;\n}\n\nexport { press };\n","import { press, frame } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\n\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.current instanceof HTMLButtonElement && node.current.disabled) {\n        return;\n    }\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle));\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = press(current, (_element, startEvent) => {\n            handlePressEvent(this.node, startEvent, \"Start\");\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\n    }\n    unmount() { }\n}\n\nexport { PressGesture };\n","/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n","import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n","import { HoverGesture } from '../../gestures/hover.mjs';\nimport { FocusGesture } from '../../gestures/focus.mjs';\nimport { PressGesture } from '../../gestures/press.mjs';\nimport { InViewFeature } from './viewport/index.mjs';\n\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n};\n\nexport { gestureAnimations };\n","import { createDomVisualElement } from '../../dom/create-visual-element.mjs';\nimport { createMotionProxy } from '../create-proxy.mjs';\nimport { featureBundle } from './feature-bundle.mjs';\n\nconst motion = /*@__PURE__*/ createMotionProxy(featureBundle, createDomVisualElement);\n\nexport { motion };\n","import { animations } from '../../../motion/features/animations.mjs';\nimport { drag } from '../../../motion/features/drag.mjs';\nimport { gestureAnimations } from '../../../motion/features/gestures.mjs';\nimport { layout } from '../../../motion/features/layout.mjs';\n\nconst featureBundle = {\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n};\n\nexport { featureBundle };\n","import { pipe } from 'motion-utils';\nimport { addDomEvent } from '../events/add-dom-event.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\n\nclass FocusGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\n        }\n        catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n    }\n    unmount() { }\n}\n\nexport { FocusGesture };\n","import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\n\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nexport { layout };\n","/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */\nfunction isNonPrimitive(n: unknown) {\n  return typeof n === 'symbol' || (typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n));\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNonPrimitive(n) && !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\nimport {isNullOrUndef} from './helpers.core.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, vScale, _parsed} = meta;\n    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n      if (spanGaps) {\n        const distanceToDefinedLo = (_parsed\n          .slice(0, start + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        start -= Math.max(0, distanceToDefinedLo);\n      }\n      start = _limitValue(start, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      let end = Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n      if (spanGaps) {\n        const distanceToDefinedHi = (_parsed\n          .slice(end - 1)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        end += Math.max(0, distanceToDefinedHi);\n      }\n      count = _limitValue(end, start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  if (!ctx && !canvas) {\n    return;\n  }\n\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type PrivateChart from '../core/core.controller.js';\nimport type {Chart, ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart | PrivateChart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart | PrivateChart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  (chart as PrivateChart).height = Math.floor(chart.height);\n  (chart as PrivateChart).width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    (chart as PrivateChart).currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import type {Chart, ChartArea, ChartMeta, Scale, TRBL} from '../types/index.js';\n\nfunction getSizeForArea(scale: Scale, chartArea: ChartArea, field: keyof ChartArea) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta: ChartMeta, chartArea: ChartArea): TRBL {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nexport function getDatasetClipArea(chart: Chart, meta: ChartMeta): TRBL | false {\n  const clip = meta._clip;\n  if (clip.disabled) {\n    return false;\n  }\n  const area = getDatasetArea(meta, chart.chartArea);\n\n  return {\n    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n  };\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n\n  if (!found && !options.all) {\n    return 0;\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data, meta) {\n  const {iScale, vScale} = meta;\n  const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n  const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find(item => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  _getAxisCount() {\n    return this._getAxis().length;\n  }\n\n  getFirstScaleIdForIndexAxis() {\n    const scales = this.chart.scales;\n    const indexScaleId = this.chart.options.indexAxis;\n    return Object.keys(scales).filter(key => scales[key].axis === indexScaleId).shift();\n  }\n\n  _getAxis() {\n    const axis = {};\n    const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n    for (const dataset of this.chart.data.datasets) {\n      axis[valueOrDefault(\n        this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId\n      )] = true;\n    }\n    return Object.keys(axis);\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    const axisCount = this._getAxisCount();\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n      const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n      const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<TimeUnit | 'datetime', string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: string): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: string): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number | boolean): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options?: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<TimeUnit | 'datetime', string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase as {\n    new (options?: AnyObject): DateAdapter;\n    override<T extends AnyObject = AnyObject>(\n      members: Partial<Omit<DateAdapter<T>, 'options'>>\n    ): void;\n  }\n};\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea, isNullOrUndef} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      const result = lookupMethod(data, axis, value);\n      if (spanGaps) {\n        const {vScale} = controller._cachedMeta;\n        const {_parsed} = metaset;\n\n        const distanceToDefinedLo = (_parsed\n          .slice(0, result.lo + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.lo -= Math.max(0, distanceToDefinedLo);\n\n        const distanceToDefinedHi = (_parsed\n          .slice(result.hi)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.hi += Math.max(0, distanceToDefinedHi);\n      }\n      return result;\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea, _isDomSupported, retinaScale, getDatasetClipArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      // Unset pending resize request now to avoid possible recursion within _resize\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    // @ts-expect-error\n    const clip = getDatasetClipArea(this, meta);\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (clip) {\n      clipArea(ctx, clip);\n    }\n\n    meta.controller.draw();\n\n    if (clip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the event inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _angleDiff, _normalizeAngle, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\nfunction clipSelf(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, x, y, outerRadius, innerRadius, options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n\n  if (innerRadius > 0) {\n    const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));\n    ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n  } else {\n    const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));\n\n    if (borderJoinStyle === 'round') {\n      ctx.arc(x, y, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);\n    } else if (borderJoinStyle === 'bevel') {\n      const r = 2 * clipWidth * clipWidth;\n      const endX = -r * Math.cos(endAngle + PI / 2) + x;\n      const endY = -r * Math.sin(endAngle + PI / 2) + y;\n      const startX = r * Math.cos(startAngle + PI / 2) + x;\n      const startY = r * Math.sin(startAngle + PI / 2) + y;\n      ctx.lineTo(endX, endY);\n      ctx.lineTo(startX, startY);\n    }\n  }\n  ctx.closePath();\n\n  ctx.moveTo(0, 0);\n  ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  ctx.clip('evenodd');\n}\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, ) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== 'miter') {\n    clipSelf(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n    selfJoin: false,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of a segment -> need to add another point before this,\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of a segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea, getDatasetClipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {chart, index, line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  const meta = chart.getDatasetMeta(index);\n  const clip = getDatasetClipArea(chart, meta);\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis, clip});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale, clip} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  let fillColor = below;\n  if (below !== above) {\n    if (property === 'x') {\n      clipVertical(ctx, target, area.top);\n      fill(ctx, {line, target, color: above, scale, property, clip});\n      ctx.restore();\n      ctx.save();\n      clipVertical(ctx, target, area.bottom);\n    } else if (property === 'y') {\n      clipHorizontal(ctx, target, area.left);\n      fill(ctx, {line, target, color: below, scale, property, clip});\n      ctx.restore();\n      ctx.save();\n      clipHorizontal(ctx, target, area.right);\n      fillColor = above;\n    }\n  }\n  fill(ctx, {line, target, color: fillColor, scale, property, clip});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction clipHorizontal(ctx, target, clipX) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(clipX, firstPoint.y);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(clipX, lastPoint.y);\n    }\n  }\n\n  ctx.lineTo(clipX, target.first().y);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale, clip} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, clip, bounds) {\n  const chartArea = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n\n  if (property === 'x' || property === 'y') {\n    let left, top, right, bottom;\n\n    if (property === 'x') {\n      left = start;\n      top = chartArea.top;\n      right = end;\n      bottom = chartArea.bottom;\n    } else {\n      left = chartArea.left;\n      top = start;\n      right = chartArea.right;\n      bottom = end;\n    }\n\n    ctx.beginPath();\n\n    if (clip) {\n      left = Math.max(left, clip.left);\n      right = Math.min(right, clip.right);\n      top = Math.max(top, clip.top);\n      bottom = Math.min(bottom, clip.bottom);\n    }\n\n    ctx.rect(left, top, right - left, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let xSet = new Set();\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    // No visible items where found, return false so we don't have to divide by 0 which reduces in NaN\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0 || (index === 0 && this.min < 0)) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if ((index === 0 && this.min >= 0) && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","function isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\nexport { isObject };\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an HTML element in a way\n * that works across iframes\n */\nfunction isHTMLElement(element) {\n    return isObject(element) && \"offsetHeight\" in element;\n}\n\nexport { isHTMLElement };\n","import { useContext, useId, useEffect, useCallback } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = useId();\n    useEffect(() => {\n        if (subscribe) {\n            return register(id);\n        }\n    }, [subscribe]);\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\nexport { isPresent, useIsPresent, usePresence };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst PresenceContext = \n/* @__PURE__ */ createContext(null);\n\nexport { PresenceContext };\n"],"names":["useIsomorphicLayoutEffect","isBrowser","useLayoutEffect","useEffect","MotionConfigContext","createContext","transformPagePoint","p","isStatic","reducedMotion","LayoutGroupContext","PopChildMeasure","React","getSnapshotBeforeUpdate","prevProps","element","this","props","childRef","current","isPresent","parent","offsetParent","parentWidth","isHTMLElement","offsetWidth","size","sizeRef","height","offsetHeight","width","top","offsetTop","left","offsetLeft","right","componentDidUpdate","render","children","PopChild","_ref","anchorX","root","id","useId","ref","useRef","nonce","useContext","useInsertionEffect","x","dataset","motionPopId","style","document","createElement","head","appendChild","sheet","insertRule","contains","removeChild","jsx","PresenceChild","initial","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","useConstant","newChildrenMap","isReusedContext","context","useMemo","childId","set","isComplete","values","register","delete","forEach","_","key","PresenceContext","Provider","value","Map","getChildKey","child","onlyElements","filtered","Children","isValidElement","push","AnimatePresence","propagate","isParentPresent","safeToRemove","usePresence","presentChildren","presentKeys","map","isInitialRender","pendingPresentChildren","exitComplete","diffedChildren","setDiffedChildren","useState","renderedChildren","setRenderedChildren","i","length","includes","get","join","exitingChildren","nextChildren","splice","forceRender","Fragment","undefined","onExit","has","isEveryExitComplete","isExitComplete","window","init","defaultDatasetIdKey","reforwardRef","setLabels","currentData","nextLabels","labels","setDatasets","nextDatasets","datasetIdKey","arguments","addedDatasets","datasets","nextDataset","currentDataset","find","data","Object","assign","cloneData","nextData","ChartComponent","redraw","type","options","plugins","fallbackContent","updateMode","canvasProps","canvasRef","chartRef","renderChart","Chart$1","destroyChart","destroy","chart","nextOptions","setOptions","config","setTimeout","update","role","Chart","forwardRef","createTypedChart","registerables","Line","LineController","Bar","BarController","Radar","RadarController","Doughnut","DoughnutController","PolarArea","PolarAreaController","Bubble","BubbleController","Pie","PieController","Scatter","ScatterController","transformPropOrder","transformProps","Set","radToDeg","rad","Math","PI","rotate","v","angle","atan2","rebaseAngle","matrix2dParsers","y","translateX","translateY","scaleX","scaleY","scale","abs","rotateZ","skewX","atan","skewY","skew","sqrt","matrix3dParsers","z","translateZ","rotateX","rotateY","defaultTransformValue","name","parseValueFromTransform","transform","matrix3dMatch","match","parsers","matrix2dMatch","valueParser","split","convertTransformToNumber","parseFloat","trim","checkStringStartsWith","token","startsWith","isCSSVariableName","startsAsVariableToken","isCSSVariableToken","singleCssVariableRegex","test","convertBoundingBoxToBox","bottom","min","max","mixNumber","from","to","progress","isIdentityScale","hasScale","hasTransform","has2DTranslate","is2DTranslate","scalePoint","point","originPoint","applyPointDelta","translate","boxScale","applyAxisDelta","axis","applyBoxDelta","box","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transformBox","originX","originY","measureViewportBox","instance","transformPoint","topLeft","bottomRight","transformBoxPoints","getBoundingClientRect","positionalKeys","clamp","number","parse","alpha","default","createUnitType","unit","endsWith","degrees","percent","px","vh","vw","progressPercentage","testValueType","dimensionValueTypes","findDimensionValueType","isNumericalString","splitCSSVariableRegex","getVariableValue","depth","fallback","exec","token1","token2","parseCSSVariable","resolved","getComputedStyle","getPropertyValue","trimmed","isNumOrPxType","transformKeys","nonTranslationalTransformKeys","filter","positionalValues","_ref2","paddingLeft","paddingRight","_ref3","_ref4","paddingTop","paddingBottom","_bbox","_ref5","_ref6","_ref7","_ref8","_ref9","_ref0","_ref1","_ref10","noop","any","MotionGlobalConfig","stepsOrder","statsBuffer","addProjectionMetrics","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","reduce","acc","stepName","thisFrame","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","numCalls","triggerCallback","callback","step","schedule","queue","add","cancel","process","frameData","frameloop","clear","createRenderStep","setup","read","resolveKeyframes","preUpdate","preRender","postRender","processBatch","useManualTiming","performance","now","keepAlive","immediate","frame","cancelFrame","frameSteps","requestAnimationFrame","toResolve","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","Array","resolver","needsMeasurement","elementsToMeasure","transformsToRestore","removedTransforms","visualElement","getValue","removeNonTranslationalTransform","measureInitialState","restore","measureEndState","suspendedScrollY","scrollTo","complete","readAllKeyframes","readKeyframes","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","motionValue","isAsync","scheduleResolve","currentValue","finalKeyframe","valueAsRead","readValue","keyframes","fillWildcards","setFinalKeyframe","renderEndStyles","isForcedComplete","resume","isZeroValueString","isNone","sanitize","round","floatRegex","singleColorRegex","isColorString","testProp","Boolean","isNullish","prototype","hasOwnProperty","call","splitColor","aName","bName","cName","a","b","c","rgbUnit","clampRgbUnit","rgba","red","green","blue","alpha$1","hex","r","g","substring","parseInt","hsla","hue","saturation","lightness","color","getAnimatableNone","parsed","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","complexRegex","analyseComplexValue","originalValue","toString","indexes","var","types","replace","parsedValue","parseComplexValue","createTransformer","source","numSections","output","convertNumbersToZero","complex","isNaN","transformer","maxDefaults","applyDefaultFilter","slice","defaultValue","functionRegex","functions","int","numberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","maxWidth","maxHeight","padding","margin","marginTop","marginRight","marginBottom","marginLeft","backgroundPositionX","backgroundPositionY","scaleZ","perspective","transformPerspective","opacity","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","defaultValueType","invalidTemplates","DOMKeyframesResolver","super","keyframe","resolveNoneKeyframes","origin","target","originType","targetType","noneKeyframeIndexes","animatableTemplate","noneIndex","makeNoneKeyframesAnimatable","pageYOffset","measuredOrigin","measureKeyframe","jump","finalKeyframeIndex","unsetTransformName","unsetTransformValue","isMotionValue","getVelocity","clearTime","time","newTime","queueMicrotask","addUniqueItem","arr","item","indexOf","removeItem","index","SubscriptionManager","subscriptions","handler","notify","numSubscriptions","getSize","velocityPerSecond","velocity","frameDuration","collectMotionValues","MotionValue","canTrackVelocity","events","updateAndNotify","currentTime","updatedAt","setPrevFrameValue","prev","setCurrent","change","dependents","dependent","dirty","hasAnimated","owner","prevFrameValue","prevUpdatedAt","onChange","subscription","on","eventName","unsubscribe","stop","clearListeners","eventManagers","attach","passiveEffect","stopPassiveEffect","setWithVelocity","endAnimation","addDependent","removeDependent","getPrevious","start","startAnimation","Promise","resolve","animation","animationStart","then","animationComplete","clearAnimation","animationCancel","isAnimating","valueTypes","microtask","cancelMicrotask","featureProps","exit","drag","focus","hover","tap","pan","inView","layout","featureDefinitions","isEnabled","some","createBox","prefersReducedMotion","hasReducedMotionListener","visualElementStore","WeakMap","isAnimationControls","isVariantLabel","isArray","variantPriorityOrder","variantProps","isControllingVariants","animate","isVariantNode","variants","getValueState","resolveVariantFromProps","definition","propEventHandlers","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","presenceContext","reducedMotionConfig","blockInitialAnimation","visualState","shouldReduceMotion","features","valueSubscriptions","prevMotionValues","propEventSubscriptions","notifyUpdate","latestValues","triggerBuild","renderInstance","renderState","projection","renderScheduledAt","scheduleRender","baseTarget","initialValues","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","mount","removeFromVariantTree","addVariantChild","bindToMotionValue","matchMedia","motionMediaQuery","setReducedMotionPreferences","matches","addEventListener","initPrefersReducedMotion","addChild","unmount","remove","feature","isMounted","enteringChildren","valueIsTransform","onBindTransform","removeOnChange","latestValue","onUpdate","isTransformDirty","removeSyncCheck","MotionCheckAppearSync","sortNodePosition","other","sortInstanceNodePosition","updateFeatures","featureDefinition","Feature","FeatureConstructor","build","measureInstanceViewportBox","getStaticValue","setStaticValue","transformTemplate","prevPresenceContext","listener","next","nextValue","prevValue","addValue","hasValue","existingValue","liveStyle","removeValue","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","getDefaultTransition","transition","getTransformPagePoint","getClosestVariantNode","closestVariantNode","removeValueFromRenderState","getBaseTargetFromProps","readValueFromInstance","setBaseTarget","getBaseTarget","valueFromInitial","variant","_len","args","_key","scheduleRenderMicrotask","DOMVisualElement","compareDocumentPosition","vars","childSubscription","latest","textContent","getValueAsType","translateAlias","numTransforms","buildHTMLStyles","transformOrigin","hasTransformOrigin","valueAsType","transformString","transformIsDefault","valueIsDefault","buildTransform","renderHTML","styleProp","elementStyle","applyProjectionStyles","setProperty","scaleCorrectors","isForcedMotionValue","layoutId","newValues","HTMLVisualElement","isProjecting","readTransformValue","computedStyle","camelToDash","str","toLowerCase","dashKeys","offset","array","camelKeys","buildSVGAttrs","isSVGTag","attrX","attrY","attrScale","pathLength","pathSpacing","pathOffset","viewBox","attrs","spacing","useDashCase","keys","buildSVGPath","camelCaseAttributes","tag","scrapeMotionValuesFromProps$1","charAt","toUpperCase","SVGVisualElement","defaultType","getAttribute","_styleProp","setAttribute","renderSVG","tagName","lowercaseSVGElements","isSVGComponent","Component","createDomVisualElement","allowProjection","LazyContext","strict","MotionContext","useCreateMotionContext","inherit","getCurrentTreeVariants","variantLabelsAsDependency","prop","createHtmlRenderState","copyRawValuesOnly","useStyle","useInitialMotionValues","useHTMLProps","htmlProps","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","tabIndex","onTap","onTapStart","whileTap","createSvgRenderState","useSVGProps","_isStatic","visualProps","rawStyles","validMotionProps","isValidMotionProp","shouldForward","isValidProp","require","useRender","forwardMotionProps","filteredProps","isDom","filterProps","elementProps","resolveMotionValue","makeLatestValues","scrapeMotionValues","motionValues","isControllingVariants$1","isVariantNode$1","isInitialAnimationBlocked","variantToSet","list","transitionEnd","valueTarget","makeUseVisualState","make","createRenderState","makeState","useHTMLVisualState","useSVGVisualState","motionComponentSymbol","Symbol","for","isRefObject","useMotionRef","externalRef","useCallback","onMount","optimizedAppearDataAttribute","SwitchLayoutGroupContext","useVisualElement","createVisualElement","ProjectionNodeConstructor","lazyContext","visualElementRef","renderer","initialLayoutGroupConfig","initialPromotionConfig","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","getClosestProjectingNode","alwaysMeasureLayout","animationType","crossfade","createProjectionNode","optimisedAppearId","wantsHandoff","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","animationState","animateChanges","MotionHandoffMarkAsComplete","createMotionComponent","preloadedFeatures","loadFeatures","useVisualState","MotionDOMComponent","MeasureLayout","configAndProps","useLayoutId","useStrictMode","layoutProjection","combined","ProjectionNode","getProjectionFunctionality","jsxs","displayName","ForwardRefMotionComponent","layoutGroupId","createMotionProxy","Proxy","componentCache","factory","deprecatedFactoryFunction","_target","resolveVariant","getValueTransition","isKeyframesTarget","setMotionValue","resolveFinalValueInKeyframes","addValueToWillChange","WillChange","newWillChange","getOptimisedAppearId","makeAnimationInstant","duration","combineFunctions","pipe","transformers","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","activeAnimations","mainThread","waapi","hueToRgb","q","t","mixImmediate","mixLinearColor","fromExpo","expo","colorTypes","asRGBA","model","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","invisibleValues","mixNumber$1","getMixer","mixComplex","mixArray","mixObject","numValues","blendValue","template","originStats","targetStats","mixVisibility","orderedOrigin","pointers","originIndex","originValue","matchOrder","mix","mixer","frameloopDriver","passTimestamp","generateLinearEasing","easing","resolution","points","numPoints","maxGeneratorDuration","calcGeneratorDuration","generator","done","Infinity","calcGeneratorVelocity","resolveValue","prevT","springDefaults","stiffness","damping","mass","bounce","visualDuration","restSpeed","granular","restDelta","minDuration","maxDuration","minDamping","maxDamping","safeMin","findSpring","envelope","derivative","dampingRatio","undampedFreq","exponentialDecay","calcAngularFreq","exp","d","e","pow","f","initialGuess","result","rootIterations","approximateRoot","durationKeys","physicsKeys","isSpringType","spring","optionsOrVisualDuration","isResolvedFromDuration","springOptions","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","resolveSpring","angularFreq","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","calculatedDuration","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toTransition","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","amplitude","ideal","calcDelta","calcLatest","applyFriction","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","applyToOptions","generatorOptions","ease","createGeneratorEasing","calcBezier","a1","a2","cubicBezier","mX1","mY1","mX2","mY2","getTForX","aX","lowerBound","upperBound","currentX","currentT","binarySubdivide","easeIn","easeOut","easeInOut","mirrorEasing","reverseEasing","backOut","backIn","backInOut","anticipate","circIn","acos","circOut","circInOut","isBezierDefinition","easingLookup","linear","easingDefinitionToFunction","x1","y1","x2","y2","toFromDifference","interpolate","input","isClamp","inputLength","isZeroDeltaRange","reverse","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","defaultOffset","remaining","offsetProgress","fillOffset","keyframeValues","times","easingFunctions","isEasingArray","absoluteTimes","o","convertOffsetToTimes","mapTimeToKeyframe","isNotNull","getFinalKeyframe","repeat","repeatType","speed","resolvedKeyframes","transitionTypeMap","decay","tween","replaceTransitionType","WithPromise","updateFinished","finished","_finished","notifyFinished","onResolve","onReject","percentToProgress","JSAnimation","startTime","isStopped","holdTime","playbackSpeed","tick","teardown","onStop","initAnimation","play","autoplay","pause","repeatDelay","keyframes$1","generatorFactory","mixKeyframes","mirroredGenerator","resolvedDuration","totalDuration","updateTime","animationTime","sample","delay","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","isAnimationFinished","finish","reject","driver","newSpeed","hasChanged","onPlay","onCancel","stopDriver","sampleTime","attachTimeline","timeline","allowFlatten","observe","memo","supportsScrollTimeline","ScrollTimeline","supportsFlags","memoSupports","supportsFlag","memoized","supportsLinearEasing","cubicBezierAsString","supportedWaapiEasing","mapEasingToNativeEasing","segmentEasing","startWaapiAnimation","valueName","pseudoElement","keyframeOptions","iterations","direction","finally","isGenerator","NativeAnimation","finishedTime","isPseudoElement","applyGeneratorOptions","onfinish","updateMotionValue","isCSSVar","setStyle","commitStyles","effect","getComputedTiming","Number","playbackRate","playState","newStartTime","updateTiming","unsupportedEasingFunctions","replaceStringEasing","NativeAnimationExtended","sampleAnimation","isAnimatable","acceleratedValues","supportsWaapi","Element","AsyncMotionValueAnimation","_animation","stopTimeline","keyframeResolver","createdAt","optionsWithDefaults","KeyframeResolver$1","forced","onKeyframesResolved","sync","isHandoff","resolvedAt","originKeyframe","targetKeyframe","isOriginAnimatable","isTargetAnimatable","hasKeyframesChanged","canAnimate","instantAnimations","resolvedOptions","subject","HTMLElement","supportsBrowserAnimation","catch","pendingTimeline","_onReject","underDampedSpring","keyframesTransition","valueKey","animateMotionValue","valueTransition","when","_delay","delayChildren","staggerChildren","staggerDirection","isTransitionDefined","shouldSkip","skipAnimations","isSync","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","targetAndTransition","transitionOverride","animations","animationTypeState","getState","MotionHandoffAnimation","appearId","all","setTarget","calcChildStagger","sort","numChildren","maxStaggerDuration","animateVariant","getAnimation","getChildAnimations","forwardDelay","animateChildren","first","last","shallowCompare","prevLength","numVariantProps","getVariantContext","reversePriorityOrder","numAnimationTypes","animateList","resolvedDefinition","animateVisualElement","createAnimationState","createState","buildResolvedTypeValues","changedActiveType","removedKeys","encounteredKeys","removedVariantIndex","typeState","propIsVariant","activeDelta","isActive","isInherited","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","resolvedValues","prevResolvedValues","allKeys","markToAnimate","valueHasChanged","willAnimateViaParent","parentVariant","fallbackAnimation","initialTransition","fallbackTarget","shouldAnimate","setActive","setAnimateFunction","makeAnimator","reset","createTypeState","whileInView","whileHover","whileDrag","whileFocus","node","updateAnimationControlsSubscription","unmountControls","subscribe","prevAnimate","prevIsPresent","exitAnimation","isDragging","isDragActive","addDomEvent","passive","removeEventListener","isPrimaryPointer","event","pointerType","button","isPrimary","extractEventInfo","pageX","pageY","addPointerEvent","addPointerInfo","calcLength","calcAxisDelta","calcBoxDelta","calcRelativeAxis","relative","calcRelativeAxisPosition","calcRelativePosition","eachAxis","getContextWindow","ownerDocument","defaultView","PanSession","handlers","contextWindow","dragSnapToOrigin","distanceThreshold","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","xDelta","yDelta","distance2D","onStart","onMove","handlePointerMove","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","lastDevicePoint","startDevicePoint","timeDelta","timestampedPoint","lastPoint","calcRelativeAxisConstraints","calcViewportAxisConstraints","layoutAxis","constraintsAxis","defaultElastic","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","label","elementDragControls","VisualElementDragControls","openDragLock","currentDirection","constraints","hasMutatedConstraints","elastic","latestPointerEvent","latestPanInfo","originEvent","snapToCursor","panSession","pauseAnimation","stopAnimation","dragPropagation","onDragStart","resolveConstraints","isAnimationBlocked","getAxisMotionValue","measuredAxis","layoutBox","dragDirectionLock","onDirectionLock","onDrag","lockThreshold","getCurrentDirection","updateAxis","getAnimationState","finalEvent","finalPanInfo","onDragEnd","_point","shouldDrag","axisValue","applyConstraints","measure","prevConstraints","resolveRefConstraints","calcRelativeConstraints","resolveDragElastic","relativeConstraints","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","rootProjectionNode","viewportBox","scroll","measurePageBox","measuredConstraints","calcViewportConstraints","userConstraints","convertBoxToBoundingBox","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","startAxisValueAnimation","dragKey","externalMotionValue","scalePositionWithinConstraints","boxProgress","sourceLength","targetLength","calcOrigin","updateScroll","updateLayout","addListeners","stopPointerListener","measureDragConstraints","stopMeasureLayoutListener","stopResizeListener","stopLayoutUpdateListener","hasLayoutChanged","asyncHandler","globalProjectionState","hasAnimatedSinceResize","hasEverUpdated","pixelsToPercent","pixels","correctBorderRadius","correct","correctBoxShadow","treeScale","projectionDelta","original","shadow","xScale","yScale","averageScale","hasTakenAnySnapshot","MeasureLayoutWithContext","componentDidMount","layoutGroup","switchLayoutGroup","correctors","isCSSVariable","addScaleCorrector","defaultScaleCorrectors","group","didUpdate","layoutDependency","willUpdate","promote","relegate","stack","getStack","members","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","deregister","applyTo","boxShadow","isSVGElement","isObject","compareByDepth","FlatTree","isDirty","timeout","checkElapsed","borders","numBorders","asNumber","isPx","getRadius","radiusName","easeCrossfadeIn","compress","easeCrossfadeOut","copyAxisInto","originAxis","copyBoxInto","originBox","copyAxisDeltaInto","originDelta","removePointDelta","removeAxisTransforms","transforms","sourceAxis","scaleKey","originKey","removeAxisDelta","xKeys","yKeys","removeBoxTransforms","sourceBox","isAxisDeltaZero","isDeltaZero","axisEquals","axisEqualsRounded","boxEqualsRounded","aspectRatio","axisDeltaEquals","NodeStack","prevLead","lead","indexOfNode","findIndex","member","preserveFollowOpacity","show","resumeFrom","preserveOpacity","snapshot","animationValues","isUpdating","isLayoutDirty","hide","exitAnimationComplete","resumingFrom","removeLeadSnapshot","metrics","nodes","calculatedTargetDeltas","calculatedProjections","transformAxes","resetDistortingTransform","sharedAnimationValues","cancelTreeOptimisedTransformAnimations","projectionNode","hasCheckedOptimisedAppear","MotionCancelOptimisedAnimation","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","resetTransform","animationId","animationCommitId","isTreeAnimating","isProjectionDirty","isSharedProjectionDirty","updateManuallyBlocked","updateBlockedByResize","isSVG","needsReset","shouldResetTransform","eventHandlers","hasTreeAnimated","updateScheduled","scheduleUpdate","projectionUpdateScheduled","checkUpdateFailed","clearAllSnapshots","updateProjection","propagateDirtyNodes","resolveTargetDelta","calcProjection","cleanDirtyNodes","resolvedRelativeTargetAt","hasProjected","isVisible","animationProgress","sharedNodes","path","notifyListeners","subscriptionManager","hasListeners","cancelDelay","innerWidth","resizeUnblockUpdate","newInnerWidth","finishAnimation","registerSharedNode","hasRelativeLayoutChanged","newLayout","isTreeAnimationBlocked","relativeTarget","layoutTransition","defaultLayoutTransition","onLayoutAnimationStart","onLayoutAnimationComplete","hasTargetChanged","targetLayout","hasOnlyRelativeTargetChanged","animationOptions","setAnimationOrigin","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","resetSkewAndRotation","getTransformTemplate","shouldNotifyListeners","prevTransformTemplateValue","updateSnapshot","clearMeasurements","clearIsLayoutDirty","resetTransformStyle","notifyLayoutUpdate","clearSnapshot","removeLeadSnapshots","scheduleUpdateProjection","measuredBox","prevLayout","layoutCorrected","phase","isRoot","wasRoot","isResetRequested","hasProjection","transformTemplateValue","transformTemplateHasChanged","removeTransform","pageBox","removeElementScroll","roundAxis","checkNodeWasScrollRoot","boxWithoutScroll","applyTransform","transformOnly","withTransforms","boxWithoutTransform","setTargetDelta","targetDelta","forceRelativeParentToResolveTarget","relativeParent","forceRecalculation","getLead","isShared","attemptToResolveRelativeTarget","getClosestProjectingParent","relativeTargetOrigin","targetWithTransforms","canSkip","pendingAnimation","prevTreeScaleX","prevTreeScaleY","treePath","isSharedTransition","treeLength","display","applyTreeDeltas","prevProjectionDelta","createProjectionDeltas","notifyAll","projectionDeltaWithTransform","snapshotLatestValues","mixedValues","relativeLayout","isSharedLayoutAnimation","isOnlyMember","shouldCrossfadeOpacity","hasOpacityCrossfade","prevRelativeTarget","mixTargetDelta","mixAxisDelta","mixAxis","follow","opacityExit","borderLabel","followRadius","leadRadius","mixValues","motionValue$1","animateSingleValue","completeAnimation","applyTransformsToTarget","shouldAnimatePositionOnly","xLength","yLength","shouldPreserveFollowOpacity","getPrevLead","hasDistortingTransform","resetValues","targetStyle","visibility","pointerEvents","valuesToRender","latestTransform","xTranslate","yTranslate","zTranslate","elementScaleX","elementScaleY","buildProjectionTransform","corrected","num","resetTree","measuredLayout","axisSnapshot","layoutDelta","visualDelta","parentSnapshot","parentLayout","relativeSnapshot","onBeforeLayoutMeasure","userAgentContains","string","navigator","userAgent","roundPoint","maxDistance","DocumentProjectionNode","documentElement","scrollLeft","body","scrollTop","HTMLProjectionNode","documentNode","position","removePointerDownListener","onPointerDown","pointerDownEvent","session","createPanHandlers","onPanSessionStart","onPanStart","onPan","onPanEnd","removeGroupControls","controls","dragControls","setupGesture","elementOrSelector","elements","scope","selectorCache","EventTarget","querySelectorAll","resolveElements","gestureAbortController","AbortController","signal","abort","isValidHover","handleHoverEvent","lifecycle","isNodeOrChild","parentElement","focusableElements","isPressing","filterEvents","firePointerEvent","dispatchEvent","PointerEvent","bubbles","isValidPressEvent","press","targetOrSelector","onPressStart","targets","eventOptions","cancelEvents","startPress","currentTarget","onPressEnd","onPointerEnd","endEvent","success","onPointerUp","onPointerCancel","upEvent","useGlobalTarget","cancelEvent","enableKeyboardPress","focusEvent","handleKeydown","handleKeyup","handleBlur","hasAttribute","handlePressEvent","HTMLButtonElement","disabled","observerCallbacks","observers","fireObserverCallback","entry","fireAllObserverCallbacks","entries","observeIntersection","rootInteresectionObserver","lookupRoot","rootObservers","JSON","stringify","IntersectionObserver","initIntersectionObserver","unobserve","thresholdNames","motion","hasEnteredView","isInView","startObserver","viewport","rootMargin","amount","once","threshold","isIntersecting","onViewportEnter","onViewportLeave","hasOptionsChanged","prevViewport","hasViewportOptionChanged","_element","globalTapTarget","onFocus","isFocusVisible","onBlur","onHoverStart","onPointerEnter","enterEvent","onHoverEnd","onPointerLeave","leaveEvent","lim","l","h","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","h1","h2","eq","hexString","isShort","HUE_RE","hsl2rgbn","s","n","k","hsv2rgbn","hwb2rgbn","w","rgb","rgb2hsl","hueValue","calln","hsl2rgb","hueParse","m","p1","p2","hwb2rgb","hsv2rgb","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","nameParse","unpacked","tkeys","j","ok","nk","unpack","transparent","RGB_RE","modHSL","ratio","tmp","clone","proto","fromObject","functionParse","rgbParse","Color","ret","len","hexParse","_rgb","_valid","valid","obj","rgbString","hslString","weight","c1","c2","w2","w1","rgb1","rgb2","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","deg","uid","isNullOrUndef","isNumberFinite","isFinite","finiteOrDefault","valueOrDefault","toDimension","dimension","fn","thisArg","apply","each","loopable","_elementsEqual","a0","ilen","v0","v1","datasetIndex","create","klen","isValidKey","_merger","tval","sval","merge","sources","merger","mergeIf","_mergerIf","keyResolvers","resolveObjectKey","parts","part","_splitKey","_getKeyResolver","_capitalize","defined","isFunction","setsEqual","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","niceNum","range","roundedRange","niceRange","fraction","isNumber","toPrimitive","isNonPrimitive","_setMinAndMaxByKey","property","toRadians","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_isBetween","_lookup","table","cmp","mid","hi","lo","_lookupByKey","ti","_rlookupByKey","arrayEvents","unlistenArrayEvents","stub","_chartjs","listeners","_arrayUnique","items","requestAnimFrame","throttled","argsToUse","ticking","_len2","_key2","_toLeftRightCenter","align","_alignStartEnd","_getStartAndCountOfVisiblePoints","meta","animationsDisabled","pointCount","count","_sorted","iScale","vScale","_parsed","spanGaps","minDefined","maxDefined","getUserBounds","getPixelForValue","distanceToDefinedLo","distanceToDefinedHi","_scaleRangesChanged","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","atEdge","elasticIn","elasticOut","effects","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","numbers","colors","intlCache","formatNumber","locale","cacheKey","formatter","Intl","NumberFormat","getNumberFormat","format","formatters","numeric","tickValue","ticks","notation","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","Ticks","overrides","descriptors","getScope$1","Defaults","_descriptors","_appliers","devicePixelRatio","platform","getDevicePixelRatio","font","family","lineHeight","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","responsive","scales","showLine","drawActiveElementsOnTop","describe","override","route","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","enumerable","local","appliers","defaults","_scriptable","_indexable","_fallback","loop","properties","active","resize","visible","autoPadding","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","_measureText","gc","longest","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","jlen","thing","nestedThing","gcLen","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","clearRect","drawPoint","drawPointLegend","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","_isPointInArea","area","clipArea","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","decorateText","line","opts","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","strokeStyle","fillStyle","decorationWidth","drawBackdrop","oldColor","fillRect","renderText","lines","strokeWidth","strokeColor","translation","textAlign","textBaseline","setRenderOpts","backdrop","strokeText","fillText","addRoundedRectPath","bottomLeft","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","numberOrZero","_readValueToProps","objProps","toTRBL","toTRBLCorners","toPadding","toFont","console","warn","toFontString","inputs","cacheable","parentContext","_createResolver","scopes","prefixes","getTarget","finalRootScopes","_resolve","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","deleteProperty","_keys","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","isScriptable","Error","_resolveScriptable","isIndexable","_resolveArray","_resolveWithContext","configurable","scriptable","indexable","_allKeys","resolveFallback","getScope","addScopes","parentScopes","parentFallback","rootScopes","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","splineCurveMonotone","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","pt","_updateBezierControlPoints","controlPoints","cubicInterpolationMode","tension","capBezierPoints","inArea","inAreaPrev","inAreaNext","_isDomSupported","_getParentNode","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","positions","getPositionedStyle","styles","suffix","pos","getRelativePosition","borderBox","boxSizing","paddings","touches","offsetX","offsetY","useOffsetPos","shadowRoot","clientX","clientY","getCanvasPosition","round1","getMaximumSize","bbWidth","bbHeight","margins","containerSize","container","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","getContainerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","readUsedSize","el","getStyle","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","getRtlAdapter","rtl","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","getPropertyPriority","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","_boundSegment","segment","startBound","endBound","getSegment","inside","subStart","shouldStart","shouldStop","_boundSegments","segments","sub","splitByStyles","segmentOptions","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","doSplitByStyles","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","replacer","getSizeForArea","chartArea","field","getDatasetClipArea","_clip","getDatasetArea","Animator","_request","_charts","_running","_lastDate","_notify","anims","date","callbacks","numSteps","currentStep","_refresh","_update","Date","running","draw","_active","_total","pop","_getAnims","charts","listen","cb","cur","_duration","animator","interpolators","boolean","factor","c0","Animation","cfg","_fn","_easing","_start","_loop","_prop","_from","_to","_promises","wait","promises","res","rej","method","Animations","_properties","configure","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","$shared","$animations","resolveTargetOptions","_createAnimations","anim","awaitAll","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","applyStack","dsIndex","singleMode","otherValue","found","isStacked","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","positive","getMatchingVisibleMetas","updateStacks","controller","_cachedMeta","_stacks","iAxis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","_visualValues","getFirstScaleId","shift","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","static","_cachedDataOpts","getMeta","_type","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","getScaleForId","rScale","getDatasetMeta","scaleID","_getOtherScale","_destroy","_dataCheck","iAxisKey","vAxisKey","adata","convertObjectDataToArray","isExtensible","defineProperty","base","object","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","NaN","getMinMax","canStack","otherScale","createStack","hidden","NEGATIVE_INFINITY","otherMin","otherMax","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","getLabelForValue","toClip","defaultClip","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","computeMinSampleSize","_cache","$bar","visibleMetas","concat","getAllScaleValues","curr","_length","updateMinAndPrev","getPixelForTick","parseValue","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","setBorderSkipped","edge","borderSkipped","horizontal","borderProps","enableBorderRadius","parseEdge","orig","v2","startEnd","setInflateAmount","inflateAmount","categoryPercentage","barPercentage","grouped","_index_","_value_","bars","getBasePixel","isHorizontal","ruler","_getRuler","vpixels","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","center","_getStacks","currentParsed","iScaleValue","skipNull","_getStackCount","_getAxisCount","_getAxis","getFirstScaleIdForIndexAxis","indexScaleId","firstScaleAxisId","_getStackIndex","barThickness","_startPixel","_endPixel","stackCount","baseValue","minBarLength","actualBase","floating","getDataVisibility","barSign","startPixel","getPixelForDecimal","endPixel","getValueForPixel","halfGrid","getLineWidthForValue","maxBarThickness","axisCount","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","axisID","axisNumber","stackIndex","rects","animateRotate","animateScale","cutout","circumference","legend","generateLabels","fontColor","legendItem","toggleDataVisibility","innerRadius","outerRadius","getter","_getRotation","_getCircumference","_getRotationExtents","isDatasetVisible","arcs","getMaxBorderWidth","getMaxOffset","maxSize","toPercentage","chartWeight","_getRingWeight","ratioX","ratioY","startAngle","endAngle","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","animationOpts","centerX","centerY","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","_dataset","_decimated","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","updateControlPoints","angleLines","circular","pointLabels","bind","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","_fullLoop","pointPosition","getPointPositionForValue","registry","getElement","abstract","DateAdapterBase","formats","diff","startOf","endOf","adapters","binarySearch","metaset","lookupMethod","_reversePixels","getRange","evaluateInteractionItems","getSortedVisibleDatasetMetas","getIntersectItems","useFinalPosition","isPointInArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getCenterPoint","getNearestItems","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","layouts","params","wrap","stackWeight","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","fullSize","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","addBox","_layers","removeBox","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","updatePos","handleMaxPadding","BasePlatform","acquireContext","releaseContext","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","createAttachObserver","observer","MutationObserver","trigger","addedNodes","removedNodes","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","native","fromNativeEvent","addListener","DomPlatform","renderHeight","renderWidth","displayWidth","displayHeight","initCanvas","removeAttribute","proxies","$proxies","detach","isConnected","tooltipPosition","final","tickOpts","determinedMaxTicks","_tickSize","maxScale","maxChart","_maxLength","determineMaxTicks","ticksLimit","maxTicksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","newTicks","ceil","skipMajors","evenMajorSpacing","getEvenSpacing","factors","_factorize","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","getTicksLimit","ticksLength","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","titleAlign","reverseAlign","Scale","_margins","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","minmax","keepZero","_addGrace","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","idx","decimal","getDecimalForPixel","getBaseValue","createTickContext","optionTicks","rot","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","positionAxisID","limit","optsAtIndex","optsAtIndexBorder","lineColor","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","titleX","titleY","titleArgs","tz","gz","bz","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","parentScope","isIChartComponent","itemDefaults","defaultRoutes","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","unregister","Registry","controllers","_typedRegistries","_each","addControllers","_len3","_key3","_len4","_key4","addPlugins","_len5","_key5","addScales","_len6","_key6","getController","_get","getPlugin","getScale","removeControllers","_len7","_key7","removeElements","_len8","_key8","removePlugins","_len9","_key9","removeScales","_len0","_key0","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","component","camelMethod","PluginService","_init","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","pluginScopeKeys","getIndexAxis","datasetDefaults","idMatchesAxis","axisFromPosition","determineAxis","_len1","scaleOptions","_key1","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","invalidatePlugins","userConfig","initialCanvas","existingChart","OffscreenCanvas","_detectPlatform","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","clearTimeout","debounce","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","buildOrUpdateControllers","newControllers","order","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","pluginId","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","_isClickEvent","lastEvent","determineLastEvent","parseBorderRadius$1","angleDelta","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","pixelMargin","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","fullCircles","inner","lineJoin","angleMargin","clipArc","selfJoin","outerAngleClip","innerAngleClip","clipWidth","clipSelf","ArcElement","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","lineCap","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","_path","strokePathWithCache","segmentMethod","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","findStartAndEnd","solidSegments","_computeSegments","_interpolate","_getInterpolationMethod","interpolated","inRange$1","hitRadius","PointElement","hoverRadius","mouseX","mouseY","inXRange","inYRange","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","inflateRect","refRect","BarElement","addRectPath","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_pointsFromSegments","_shouldApplyFill","_resolveTarget","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","unshift","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","below","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","above","fillColor","clipVertical","clipHorizontal","doFill","clipY","lineLoop","clipX","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","_args","$filler","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","adjustHitBoxes","rtlHelper","hitbox","_draw","defaultColor","halfFontSize","cursor","textDirection","lineDash","drawOptions","SQRT2","yBoxTop","xBoxLeft","drawLegendBox","_textX","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","sameItem","itemsEqual","plugin_legend","afterEvent","ci","useBorderRadius","Title","_padding","textSize","_drawArgs","fontOpts","plugin_title","titleBlock","createTitle","positioners","average","xSet","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","createTooltipItem","formattedValue","getTooltipSize","tooltip","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","beforeTitle","tooltipItems","labelCount","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","findOrAddLabel","addedLabels","addIfString","lastIndexOf","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","generateTicks$1","generationOptions","dataRange","precision","maxTicks","maxDigits","includeBounds","maxSpaces","rmin","rmax","countDefined","minSpacing","niceMin","niceMax","numSpaces","rounded","almostWhole","decimalPlaces","relativeLabelSize","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","stepSize","computeTickLimit","LinearScale","getTickBackdropHeight","measureLabelSize","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","updateLimits","setCenterPoint","_pointLabelItems","itemOpts","extra","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","RadialLinearScale","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","gridLineOpts","drawRadiusLine","INTERVALS","millisecond","common","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","displayFormats","_unit","_majorUnit","_offsets","_normalized","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_filterBetween","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel"],"sourceRoot":""}